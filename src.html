<!DOCTYPE html>
<html lang="en">
  <head>
    <title>FPS3 Prototype</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      @font-face {
        font-family: "Roboto";
        src: url(fonts/Roboto.ttf);
      }
      html, body {
        margin: 0;
        overflow: hidden;
      }
      .ui .crosshair {
        position: fixed;
        width: 40px;
        height: 40px;
        margin: 0;
        left: 50%;
        top: 50%;
        margin-left: -20px;
        margin-top: -25px;
      }
      .ui-centering, .center {
        margin: 0;
        padding: 0;
      }
      .ui img, .ui .drop-shadow {
        filter: drop-shadow(3px 3px 3px rgba(0, 0, 0, .3));
      }
      .ui .container {
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .font-size-large {
        font-size: 30px;
      }
      * {
        font-family: "Roboto", Arial;
        color: #fff;
        text-shadow: 1px 2px 3px rgba(0, 0, 0, 0.3);
      }
      .ui .primary-holder {
        position: absolute;
        left: 2%;
      }
      .ui .secondary-holder {
        position: absolute;
        left: 2%;
        bottom: 80px;
      }
      .ui .third-holder {
        position: absolute;
        left: 2%;
        bottom: 40px;
      }
      .ui .health-display {
        background: rgba(0, 0, 0, .25);
        width: 130px;
        height: 15px;
        padding: 0;
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .ui .health, .ui .run-health {
        position: relative;
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
        background: #fff;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.24);
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .ui .health span, .ui .run-health span {
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      img {
        pointer-events: none !important;
      }
    </style>
	  <script src="https://cdn.jsdelivr.net/gh/Parking-Master/Gametime.js-2.0@latest/gametime.js"></script>
  </head>
  <body>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/js/math/Capsule.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/js/math/Octree.min.js"></script>
    <script src="https://mrgoonie.github.io/three.confetti.explosion.js/js/helper.js"></script>
    <script src="js/PointerLockControls.min.js"></script>
    <div class="ui">
      <img class="vignette" src="images/other/blurred_border.png" style="transition: opacity .15s; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: 0; padding: 0;">
      <div class="ui-centering center">
        <img src="images/icons/ui/crosshair.png" class="crosshair drop-shadow">
      </div>
      <div class="ui-holder primary-holder holder">
        <div class="container">
          <p class="placeholder font-size-large current-grenades">0</p><img src="images/icons/ui/grenade.png" style="width: 50px"><p class="placeholder font-size-large">|</p>&ThickSpace;&ThickSpace;<p class="placeholder font-size-large current-ammo">0</p><img src="images/icons/ui/bullet.png" style="width: 50px">
        </div>
      </div>
      <div class="ui-holder secondary-holder holder">
        <div class="health-display">
          <div class="health"><span style="color: #333; display: inline-block; font-size: 12px; white-space: nowrap; display: inline-flex; text-align: center; align-items: center; justify-content: center"><img src="images/icons/heart.png" style="width: 15px"><span class="health-text" style="color: #333">100</span> %</span></div>
        </div>
      </div>
      <div class="ui-holder third-holder holder">
        <div class="health-display">
          <div class="run-health"><span style="color: #333; display: inline-block; font-size: 12px; white-space: nowrap; display: inline-flex; text-align: center; align-items: center; justify-content: center"><img src="images/icons/fast_forward.png" style="width: 20px"><span class="health-text" style="color: #333">100</span> %</span></div>
        </div>
      </div>
    </div>
    <script>
	  // Game asset variables
	  otherPlayer = new THREE.Mesh();

	  THREE.Sound = function Sound(source = null, object = new THREE.Object3D, callback = function(sound) {}, preserve3d = true, volume = 5) {
      if (!preserve3d) {
        let sound = document.createElement("audio");
        sound.src = source;
        sound.play();
        return;
      }
	    typeof camera.getObjectByProperty("type", "AudioListener") == "undefined" && camera.add(new THREE.AudioListener());
		  let sound = new THREE.PositionalAudio(camera.getObjectByProperty("type", "AudioListener"));
		  new THREE.AudioLoader().load(source, (buffer) => {
		    sound.setBuffer(buffer);
		    sound.setRefDistance(5);
		    sound.setVolume(volume);
		    callback(sound);
		    sound.play();
		  });
		  object.add(sound);
	  }
	  utils = {
      cache: {
        options: {}
      },
      options: {
        set: function(key, value) {
          utils.cache.options[key] = value;
        },
        get: function(key) {
          return utils.cache.options[key];
        },
        defineWeapon: function(options = {}) {
          sandbox.weapons.push(options);
        }
      },
      player: {
        weapon: {
          set: function(key) {
            sandbox.weapons.forEach(x => {
              if (x.name == key) {
                let gun = x.object.getObjectByName("handR_025").children[x.object.getObjectByName("handR_025").children.length - 1].clone();
                gun.scale.set(10, 10, 10);
                gun.rotation.set(0, 0, -Math.PI / 2);
                gun.translateX(-12);
                gun.translateY(2);
                sandbox.models["player"].object.getObjectByName("mixamorigRightHand").add(gun);
              }
            });
          }
        }
      },
      camera: {
        shake: function(intensity) {
          let t = 0;
          let h = setInterval(() => {
            if (t >= intensity / 20) {
              return (() => {
                let t = 0;
                let h = setInterval(() => {
                  if (t >= intensity / 20) {
                    return clearInterval(h);
                  }
                  camera.rotateX(-.005);
                  t += .005;
                });
              })(), clearInterval(h);
            }
            camera.rotateX(.005);
            t += .005;
          });
        },
        zoomIn: function(o) {
          if (utils.options.get("Zoomed")) return;
          utils.options.set("Zoomed", true);
          const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
          let t = 0;
          let transition = setInterval(() => {
            t >= 26 ? clearInterval(transition) : camera.fov = e - t;
            t += 2;
            camera.updateProjectionMatrix();
          });
          document.querySelector(".crosshair").src = "images/icons/ui/crosshair_zoomed.png";
          PointerControls.pointerSpeed = PointerControls.pointerSpeed / 2;
          document.querySelector(".vignette").style.opacity = 0;
        },
        zoomOut: function(o) {
          if (!utils.options.get("Zoomed")) return;
          utils.options.set("Zoomed", false);
          const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
          let t = 0;
          let transition = setInterval(() => {
            t >= 26 ? clearInterval(transition) : camera.fov = e + t;
            t += 2;
            camera.updateProjectionMatrix();
          });
          document.querySelector(".crosshair").src = "images/icons/ui/crosshair.png";
          PointerControls.pointerSpeed = PointerControls.pointerSpeed * 2;
          document.querySelector(".vignette").style.opacity = 1;
        }
      },
	    weapons: {
        punch: function() {
          if (utils.options.get("Punching")) return;
          utils.options.set("Punching", true);
          setTimeout(() => utils.camera.shake(1), 200);
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            setTimeout(() => (utils.options.set("Punching", false), weapon.mixer.clipAction(weapon.animations[11]).stop()), 1500);
            let clip = weapon.mixer.clipAction(weapon.animations[11]);
            clip.loop = THREE.LoopOnce;
            clip.clampWhenFinished = true;
            clip.reset();
            clip.setDuration(.5);
            clip.play();
            setTimeout(() => (clip.timeScale = -1, clip.paused = false), 500);
          });
        },
        data: function(weapon) {
          return new Promise(function(resolve, reject) {
            sandbox.weapons.forEach(x => x.object == weapon && resolve(x));
          });
        },
        shoot: function(rounds = 1) {
          if (!utils.options.get("CanFire")) return;
          let i = 0;
          let weapon = null;
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            weapon = x;
          });
          let shooting = setInterval(() => {
            if (i >= rounds) {
              return clearInterval(shooting);
            }
            i++;
            if (weapon) {
              let cweapon = sandbox.weapons[sandbox.weapons.indexOf(weapon)];
              if (cweapon.rounds - 1 <= cweapon.minRounds) {
                utils.weapons.reload();
              }
              if (cweapon.rounds <= cweapon.minRounds) {
                return;
              }
              cweapon.rounds--;
              cweapon.roundsUsed++;
            }
            sandbox.weapons.forEach(x => x.object == sandbox.currentWeapon && (x.mixer.clipAction(x.animations[2]).reset(), x.mixer.clipAction(x.animations[2]).loop = THREE.LoopOnce, x.mixer.clipAction(x.animations[2]).reset(), x.mixer.clipAction(x.animations[2]).play(), x.mixer.clipAction(x.animations[2]).timeScale = 5, x.mixer.clipAction(x.animations[2]).fadeIn()));
            utils.camera.shake(.2);
            let flash = sandbox.models["flash"].object;
            new THREE.Sound("sounds/guns/" + weapon.name + "/fire.mp3", sandbox.currentWeapon, () => {}, false);
            flash.children[0].material.opacity = 1;
            flash.scale.set(.1, .1, .1);
            flash.position.copy(sandbox.currentWeapon.position);
            flash.rotation.copy(sandbox.currentWeapon.rotation);
            flash.translateY(.11);
            flash.rotateY(Math.PI);
            flash.translateX(.08);
            flash.translateZ(-.3);
            let sticky = setInterval(() => {
              flash.position.copy(sandbox.currentWeapon.position);
              flash.rotation.copy(sandbox.currentWeapon.rotation);
              flash.translateY(.11);
              flash.rotateY(Math.PI);
              flash.translateX(.08);
              flash.translateZ(-.3);
            });
            let shell = sandbox.models["shell"].object;
            shell.position.copy(sandbox.currentWeapon.position);
            shell.rotation.copy(sandbox.currentWeapon.rotation);
            shell.scale.copy(sandbox.currentWeapon.scale);
            weaponScene.add(shell);
            let effect = setInterval(() => {
              shell.translateX(-.07);
              shell.position.y += -.03;
            });
            setTimeout(() => (scene.remove(shell), clearInterval(effect)), 1000);
            let light = new THREE.PointLight(0xf99c00, 1, 4, 3);
            light.position.copy(flash.position);
            light.rotation.copy(flash.rotation);
            weaponScene.add(flash);
            scene.add(light);
            let lightClone = light.clone();
            weaponScene.add(lightClone);
            document.querySelector(".crosshair").style.transition = "transform .05s ease-out", document.querySelector(".crosshair").style.transform = "scale(1.15)", setTimeout(() => document.querySelector(".crosshair").style.transform = "", 100);
            setTimeout(() => (weaponScene.remove(flash), weaponScene.remove(lightClone), scene.remove(light), clearInterval(sticky)), 25);
          }, 60);
        },
		    switch: function() {
		    	let newWeapon;
		    	let oldWeapon = sandbox.currentWeapon;
		      if (sandbox.currentWeapon == sandbox.primaryWeapon)
		  	    newWeapon = sandbox.secondaryWeapon;
		  	  else newWeapon = sandbox.primaryWeapon;
		  	  weaponScene.remove(oldWeapon);
		  	  sandbox.currentWeapon = newWeapon;
		  	  sandbox.weapons.forEach(x => {
		  	    if (!(x.object == sandbox.currentWeapon)) return;
		  	    x.mixer.clipAction(x.animations[0]).reset();
		  	    x.mixer.clipAction(x.animations[0]).loop = THREE.LoopOnce;
		  	    x.mixer.clipAction(x.animations[0]).play();
		  	  });
		  	  weaponScene.add(sandbox.currentWeapon);
		    },
		    reload: function() {
          if (utils.options.get("Reloading")) return;
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            if (weapon.clips <= weapon.minClips) return;
            utils.options.set("CanFire", false);
            utils.options.set("Reloading", true);
            weapon.roundsUsed += weapon.rounds;
            keyStates["ShiftLeft"] = false;
            weapon.mixer.clipAction(weapon.animations[1]).stop();
            weapon.mixer.clipAction(weapon.animations[6]).stop();
            weapon.mixer.clipAction(weapon.animations[7]).stop();
            if (weapon.rounds <= 0) {
              weapon.mixer.clipAction(weapon.animations[4]).timeScale = 2.5;
              weapon.mixer.clipAction(weapon.animations[4]).loop = THREE.LoopOnce;
              weapon.mixer.clipAction(weapon.animations[4]).reset();
              weapon.mixer.clipAction(weapon.animations[4]).play();
            } else {
              weapon.mixer.clipAction(weapon.animations[3]).timeScale = 2.5;
              weapon.mixer.clipAction(weapon.animations[3]).loop = THREE.LoopOnce;
              weapon.mixer.clipAction(weapon.animations[3]).reset();
              weapon.mixer.clipAction(weapon.animations[3]).play();
            }
            setTimeout(() => {
              sandbox.weapons[sandbox.weapons.indexOf(weapon)].rounds = sandbox.weapons[sandbox.weapons.indexOf(weapon)].maxRounds;
              sandbox.weapons[sandbox.weapons.indexOf(weapon)].clips--;
              utils.options.set("CanFire", true);
              utils.options.set("Reloading", false);
              if ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"])) {
                weapon.mixer.clipAction(weapon.animations[6]).play();
              }
            }, 3000);
          });
        },
        unlock: function() {
          utils.options.set("WeaponLocked", false);
        },
        lock: function() {
          utils.options.set("WeaponLocked", true);
        },
        grenades: {
          throw: function() {
            if (sandbox.grenades.current <= sandbox.grenades.min) {
              return;
            }
            if (utils.options.get("Punching")) return;
            utils.options.set("Punching", true);
            utils.weapons.data(sandbox.currentWeapon).then(weapon => {
              setTimeout(() => (utils.options.set("Punching", false), weapon.mixer.clipAction(weapon.animations[10]).stop()), 500);
              let clip = weapon.mixer.clipAction(weapon.animations[10]);
              let clipFrom = weapon.mixer.clipAction(weapon.animations[1]);
              clip.loop = THREE.LoopOnce;
              clip.reset();
              clip.setDuration(.5);
              clip.play();
              clip.crossFadeFrom(clipFrom);
            });
            sandbox.grenades.current--;
            setTimeout(() => utils.camera.shake(.5), 100);
            const sphere = spheres[sphereIdx];
            camera.getWorldDirection(playerDirection);
            sphere.collider.center.copy(playerCollider.end).addScaledVector(playerDirection, playerCollider.radius * 1.5);
            const impulse = 15 + 30 * (1 - Math.exp((mouseTime - performance.now()) * 0.001));
            sphere.velocity.copy(playerDirection).multiplyScalar(impulse);
            sphere.velocity.addScaledVector(playerVelocity, 2);
            sphereIdx = (sphereIdx + 1) % spheres.length;
            !(scene.children.indexOf(sphere.mesh) > -1) && scene.add(sphere.mesh);
            let collided = setInterval(() => {
              if (worldOctree.sphereIntersect(sphere.collider)) {
                setTimeout(() => {
                  utils.explosion(sphere.mesh);
                  scene.remove(sphere.mesh);
                  new THREE.Sound("sounds/explosion.mp3", sphere.mesh, () => {}, true, 20);
                  sphere.hits = 0;
                }, 1000);
                clearInterval(collided);
              }
            });
          }
        }
		  },
      explosion: function(obj) {
        let explosion = new THREE.Mesh(new THREE.CircleGeometry(1), new THREE.MeshBasicMaterial({ color: 0xffffff, map: new THREE.TextureLoader().load("images/textures/explosion.png"), transparent: true, opacity: .1, depthWrite: false }));
        let light = new THREE.PointLight(0xbb3905, 1);
        let lightClone = light.clone();
        scene.add(explosion);
        explosion.position.copy(obj.position);
        explosion.scale.set(.2, .2, .2);
        let fadeIn1 = setInterval(() => {
          if (explosion.material.opacity >= 1) {
            clearInterval(fadeIn1);
          } else {
            explosion.material.opacity += .15;
            light.intensity += .5;
            lightClone.intensity += .5;
          }
          explosion.lookAt(camera.position);
        });
        let fadeIn = setInterval(() => {
          if (explosion.scale.x >= 3) {
            clearInterval(fadeIn);
          } else {
            let increment = .05;
            explosion.scale.set(explosion.scale.x + increment, explosion.scale.y + increment, explosion.scale.z + increment);
          }
          explosion.lookAt(camera.position);
        });
        let spin = setInterval(() => { explosion.rotateZ(.1) });
        setTimeout(() => {
          let fadeOut = setInterval(() => {
            if (explosion.material.opacity <= 0) {
              scene.remove(light);
              weaponScene.remove(lightClone);
              scene.remove(explosion);
              clearInterval(fadeOut);
              clearInterval(spin);
            } else {
              explosion.material.opacity += -.08;
              light.intensity <= 0 ? light.intensity = 0 : light.intensity += -.8;
              lightClone.intensity <= 0 ? lightClone.intensity = 0 : lightClone.intensity += -.8;
            }
            explosion.lookAt(camera.position);
          });
        }, 500);
        scene.add(light);
        light.position.copy(obj.position);
        weaponScene.add(lightClone);
      }
	  };
      sandbox = {
        loadout: ["Assault_Rifle", "Glock_19"],
        weapons: [
          {
            name: "Assault_Rifle",
            rounds: 36,
            minRounds: 0,
            maxRounds: 36,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 1500
              },
              full: {
                sound: null,
                time: 2000
              }
            }
          },
          {
            name: "Glock_19",
            rounds: 12,
            minRounds: 0,
            maxRounds: 12,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 1000
              },
              full: {
                sound: null,
                time: 1250
              }
            }
          },
        ],
        grenades: {
          min: 0,
          max: 2,
          current: 2,
          types: ["hand"]
        },
        currentWeapon: null,
        primaryWeapon: null,
        secondaryWeapon: null,
        models: {
          "grenade": {
            srcPath: "models/weapons/grenades/hand.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "flash": {
            srcPath: "models/assets/muzzle_flash.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "shell": {
            srcPath: "models/assets/bullet_shell.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "player": {
            srcPath: "models/characters/Steve/scene.gltf",
            object: null,
            callback: function(model) {
              model.scale.set(.8, .8, .8);
              scene.add(model);
              model.traverse(x => x.frustumCulled = false);
              model.position.set(17, 0, -2.25);
            },
            mixer: null,
            animations: null
          },
        }
      };
      const clock = new THREE.Clock();
      const scene = new THREE.Scene();
      const sun = new THREE.Mesh(new THREE.CircleGeometry(10), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/sun.png"), transparent: true }));
      scene.background = new THREE.Color(0x88ccee);
      sun.position.set(0, 50, 0);
      sun.rotateX(1);
      scene.add(sun);
      scene.fog = new THREE.Fog(0x88ccee, 0, 100);
      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.rotation.order = "YXZ";
      const fillLight1 = new THREE.HemisphereLight(0x4488bb, 0x002244, 0.5);
      fillLight1.position.set(2, 1, 1);
      scene.add(fillLight1);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(-5, 25, -1);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.near = 0.01;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.right = 30;
      directionalLight.shadow.camera.left = -30;
      directionalLight.shadow.camera.top = 30;
      directionalLight.shadow.camera.bottom = -30;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.radius = 4;
      directionalLight.shadow.bias = -0.00006;
      scene.add(directionalLight);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.VSMShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.body.appendChild(renderer.domElement);
      const GRAVITY = 60;
      const NUM_SPHERES = 2;
      const SPHERE_RADIUS = 0.2;
      const STEPS_PER_FRAME = 10;
      const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
      const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xbbbb44 });
      const spheres = [];
      let sphereIdx = 0;
      for (let i = 0; i < NUM_SPHERES; i++) {
        let loader = setInterval(() => {
          if (sandbox.models["grenade"].object != null && spheres.length < 2) {
            const sphere = sandbox.models["grenade"].object.clone();
            if (sphere) {
              scene.add(sphere);
              spheres.push({
                mesh: sphere,
                collider: new THREE.Sphere(new THREE.Vector3(0, - 100, 0), SPHERE_RADIUS),
                velocity: new THREE.Vector3()
              });
            }
            clearInterval(loader);
          }
        });
      }
      const worldOctree = new THREE.Octree();
      const playerCollider = new THREE.Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1, 0), 0.35);
      playerCollider.start.set(13.5, 0.35, -18.5);
      playerCollider.end.set(13.5, 1, -18.5);
      playerCollider.radius = 0.35;
      camera.position.copy(playerCollider.end);
      camera.rotation.set(0,Math.PI,0);
      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();
      let playerOnFloor = false;
      let mouseTime = 0;
      const keyStates = {};
      const vector1 = new THREE.Vector3();
      const vector2 = new THREE.Vector3();
      const vector3 = new THREE.Vector3();
      document.addEventListener("keydown", (event) => {
        keyStates[event.code] = true;
        if (keyStates["ShiftLeft"] && ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"]))) {
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("RunHealth") <= 0 ? (weapon.mixer.clipAction(weapon.animations[7]).play(), weapon.mixer.clipAction(weapon.animations[7]).reset(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[7]), .4), keyStates["ShiftLeft"] = false) : utils.options.set("RunHealth", utils.options.get("RunHealth") - 2);
          });
        }
        if ((keyStates["KeyW"] || keyStates["ArrowUp"]) && !event.repeat) {
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            if (keyStates["ShiftLeft"]) {
              utils.options.get("Reloading") || (weapon.mixer.clipAction(weapon.animations[6]).crossFadeTo(weapon.mixer.clipAction(weapon.animations[7]), .4), weapon.mixer.clipAction(weapon.animations[7]).reset(), weapon.mixer.clipAction(weapon.animations[7]).play());
            } else {
              utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
            }
          });
        }
        if (keyStates["KeyR"] && !event.repeat) {
          utils.weapons.reload();
        }
        if (keyStates["KeyI"] && !event.repeat) {
          utils.options.get("Zoomed") ? utils.camera.zoomOut() : utils.camera.zoomIn();
        }
        if (keyStates["KeyB"] && !event.repeat) {
          utils.weapons.punch();
        }
        if (keyStates["KeyF"] && !event.repeat) {
          document.dispatchEvent(new MouseEvent("mousedown"));
        }
        if (keyStates["KeyY"] && !event.repeat) {
          utils.weapons.switch();
        }
        if (keyStates["KeyM"] && !event.repeat) {
          utils.weapons.grenades.throw();
        }
      });
      document.addEventListener("keyup", (event) => {
        keyStates[event.code] = false;
        sandbox.weapons.forEach(weapon => {
          weapon.mixer.clipAction(weapon.animations[6]).stop(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[7]), .4), weapon.mixer.clipAction(weapon.animations[7]).play();
          if ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"])) {
            weapon.mixer.clipAction(weapon.animations[6]).play();
          }
          if (keyStates["KeyF"]) {
            document.dispatchEvent(new MouseEvent("mouseup"));
          }
        });
      });
      renderer.domElement.addEventListener("mousedown", () => {
        if (document.pointerLockElement != null) return;
        document.body.requestPointerLock();
        PointerControls.lock();
        mouseTime = performance.now();
      });
      document.addEventListener("mouseup", () => {
        PointerControls.lock();
      });
      document.body.addEventListener("mousemove", (event) => { });
      window.addEventListener("resize", onWindowResize);
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        weaponCamera.aspect = window.innerWidth / window.innerHeight;
        weaponCamera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        weaponRenderer.setSize(window.innerWidth, window.innerHeight);
      }
      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;
        if (result) {
          playerOnFloor = result.normal.y > 0;
          if (!playerOnFloor) {
            playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
          }
          playerCollider.translate(result.normal.multiplyScalar(result.depth));
        }
      }
      function updatePlayer(deltaTime) {
        let damping = Math.exp(- 4 * deltaTime) - 1;
        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * (deltaTime);
          damping *= 0.1;
        }
        playerVelocity.addScaledVector(playerVelocity, damping);
        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);
        playerCollisions();
        camera.position.copy(playerCollider.end);
      }
      function playerSphereCollision(sphere) {
        const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);
        const sphere_center = sphere.collider.center;
        const r = playerCollider.radius + sphere.collider.radius;
        const r2 = r * r;
        for (const point of [playerCollider.start, playerCollider.end, center]) {
          const d2 = point.distanceToSquared(sphere_center);
          if (d2 < r2) {
            const normal = vector1.subVectors(point, sphere_center).normalize();
            const v1 = vector2.copy(normal).multiplyScalar(normal.dot(playerVelocity));
            const v2 = vector3.copy(normal).multiplyScalar(normal.dot(sphere.velocity));
            playerVelocity.add(v2).sub(v1);
            sphere.velocity.add(v1).sub(v2);
            const d = (r - Math.sqrt(d2)) / 2;
            sphere_center.addScaledVector(normal, - d);
          }
        }
      }
      function spheresCollisions() {
        for (let i = 0, length = spheres.length; i < length; i++) {
          const s1 = spheres[i];
          for (let j = i + 1; j < length; j++) {
            const s2 = spheres[j];
            const d2 = s1.collider.center.distanceToSquared(s2.collider.center);
            const r = s1.collider.radius + s2.collider.radius;
            const r2 = r * r;
            if (d2 < r2) {
              const normal = vector1.subVectors(s1.collider.center, s2.collider.center).normalize();
              const v1 = vector2.copy(normal).multiplyScalar(normal.dot(s1.velocity));
              const v2 = vector3.copy(normal).multiplyScalar(normal.dot(s2.velocity));
              s1.velocity.add(v2).sub(v1);
              s2.velocity.add(v1).sub(v2);
              const d = (r - Math.sqrt(d2)) / 2;
              s1.collider.center.addScaledVector(normal, d);
              s2.collider.center.addScaledVector(normal, - d);
            }
          }
        }
      }
      function updateSpheres(deltaTime) {
        spheres.forEach(sphere => {
          sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);
          const result = worldOctree.sphereIntersect(sphere.collider);
          if (result) {
            sphere.hits || (sphere.hits = 0);
            if (scene.children.indexOf(sphere.mesh) > -1 && sphere.hits < 4) {
              let hits = ["ricochet1", "ricochet2", "ricochet3"];
              sphere.hits++;
              new THREE.Sound("sounds/" + hits[Math.floor(Math.random() * hits.length)] + ".mp3", sphere.mesh);
            }
            sphere.velocity.addScaledVector(result.normal, - result.normal.dot(sphere.velocity) * 1.5);
            sphere.collider.center.add(result.normal.multiplyScalar(result.depth));
          } else {
            sphere.velocity.y -= (GRAVITY * deltaTime + .01);
          }
          const damping = Math.exp(- 1.5 * deltaTime) - 1.003;
          sphere.velocity.addScaledVector(sphere.velocity, damping);
          playerSphereCollision(sphere);
        });
        spheresCollisions();
        for (const sphere of spheres) {
          sphere.mesh.position.copy(sphere.collider.center);
        }
      }
      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }
      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }
      const loader = new THREE.GLTFLoader();
      loader.load("models/maps/Cargo.glb", (gltf) => {
        worldOctree.fromGraphNode(gltf.scene);
        scene.add(gltf.scene);
        gltf.scene.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material.map) {
              child.material.map.anisotropy = 4;
            }
          }
        });
        function isSustained() {
          return new Promise(function(resolve, reject) {
            let t = camera.position;
            setTimeout(() => t.y - .02 >= camera.position.y ? resolve(!true) : resolve(!false), 100);
          });
        }
        let animated = false;
        let checkSustained = setInterval(() => {
          isSustained().then(sustained => {
            if (sustained) {
              !animated && animate();
              animated = true;
              clearInterval(checkSustained);
            }
          });
        });
        updateShadows();
      });
      function updateShadows() {
        renderer.shadowMap.needsUpdate = true;
      }
      function teleportPlayerIfOob() {
        if (camera.position.y <= -25) {
          playerCollider.start.set(13.5, 0.35, -18.5);
          playerCollider.end.set(13.5, 1, -18.5);
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0,Math.PI,0);
        }
      }
      function controls(deltaTime) {
        const speedDelta = .025;
        if (keyStates["KeyW"] || keyStates["ArrowUp"]) {
          playerVelocity.add(getForwardVector().multiplyScalar(keyStates["ShiftLeft"] ? speedDelta + .05 : speedDelta));
        }
        if (keyStates["KeyS"] || keyStates["ArrowDown"]) {
          playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
        }
        if (keyStates["KeyA"] || keyStates["ArrowLeft"]) {
          playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
        }
        if (keyStates["KeyD"] || keyStates["ArrowRight"]) {
          playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
        }
        if (playerOnFloor) {
          if (keyStates["Space"]) {
            playerVelocity.y = 10;
          }
        }
      }
      function animate() {
        requestAnimationFrame(animate);
        utils.options.get("RunHealth") >= 100 ? utils.options.set("RunHealth", 100) : keyStates["ShiftLeft"] || utils.options.set("RunHealth", utils.options.get("RunHealth") + 1);
        document.querySelector(".run-health").style.width = (utils.options.get("RunHealth") <= 0 ? 0 : utils.options.get("RunHealth")) + "%";
        document.querySelector(".run-health").querySelector("span").querySelector("span").textContent = (utils.options.get("RunHealth") <= 0 ? 0 : utils.options.get("RunHealth"));
        document.querySelector(".current-grenades").textContent = sandbox.grenades.current;
        sandbox.currentWeapon && utils.weapons.data(sandbox.currentWeapon).then(weapon => {
          document.querySelector(".current-ammo").textContent = (weapon.maxRounds * (weapon.maxClips + 1)) - weapon.roundsUsed;
        });
        if (sandbox.primaryWeapon != null && sandbox.secondaryWeapon != null && utils.options.get("WeaponLocked")) {
          sandbox.primaryWeapon.position.copy(camera.position);
          sandbox.primaryWeapon.rotation.copy(camera.rotation);
          sandbox.primaryWeapon.rotateY(Math.PI);
          sandbox.primaryWeapon.translateX(-.1);
          sandbox.primaryWeapon.translateZ(.3);
          sandbox.primaryWeapon.translateY(-.15);
          sandbox.secondaryWeapon.position.copy(camera.position);
          sandbox.secondaryWeapon.rotation.copy(camera.rotation);
          sandbox.secondaryWeapon.rotateY(Math.PI);
          sandbox.secondaryWeapon.translateX(-.1);
          sandbox.secondaryWeapon.translateZ(.3);
          sandbox.secondaryWeapon.translateY(-.15);
        }
        const deltaTime = clock.getDelta();
        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          controls(deltaTime);
          updatePlayer(deltaTime);
          updateSpheres(deltaTime);
          teleportPlayerIfOob();
        }
        renderer.render(scene, camera);
      }
      sandbox.weapons.forEach(x => {
        new THREE.GLTFLoader().load(`models/weapons/${x.name}.glb`, (model) => {
          x.object = model.scene;
          x.object.scale.set(.01, .01, .01);
          x.animations = model.animations;
          x.mixer = new THREE.AnimationMixer(model.scene);
          x.roundsUsed = 0;
          let weapon = x;
          weapon.mixer.clipAction(weapon.animations[6]).stop(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[7]), .4), weapon.mixer.clipAction(weapon.animations[7]).play();
          if (x.name == sandbox.loadout[0]) {
            sandbox.primaryWeapon = x.object;
            sandbox.currentWeapon = x.object;
            weaponScene.add(sandbox.primaryWeapon);
          }
          if (x.name == sandbox.loadout[1]) {
            sandbox.secondaryWeapon = x.object;
          }
        });
      });
      Object.keys(sandbox.models).forEach(x => {
        new THREE.GLTFLoader().load(sandbox.models[x].srcPath, (model) => {
          sandbox.models[x].object = model.scene;
          sandbox.models[x].mixer = new THREE.AnimationMixer(model.scene);
          sandbox.models[x].animations = model.animations;
          sandbox.models[x].callback(model.scene);
        });
      });
      const weaponRenderer = new THREE.WebGLRenderer({ antialias: true });
      weaponRenderer.setPixelRatio(window.devicePixelRatio);
      weaponRenderer.setSize(window.innerWidth, window.innerHeight);
      weaponRenderer.outputEncoding = THREE.sRGBEncoding;
      weaponRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.body.appendChild(weaponRenderer.domElement);
      const weaponScene = new THREE.Scene();
      const weaponCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      const PointerControls = new PointerLockControls(camera, renderer.domElement);
      PointerControls.isLocked = true;
      weaponCamera.rotation.order = "YXZ";
      function weaponAnimate() {
        const delta = clock.getDelta();
        requestAnimationFrame(weaponAnimate);
        sun.position.set(camera.position.x, 50, camera.position.z);
        weaponCamera.position.copy(camera.position);
        weaponCamera.rotation.copy(camera.rotation);
        if (sandbox.primaryWeapon != null && sandbox.secondaryWeapon != null && utils.options.get("WeaponLocked")) {
          sandbox.primaryWeapon.position.copy(weaponCamera.position);
          sandbox.primaryWeapon.rotation.copy(weaponCamera.rotation);
          sandbox.primaryWeapon.rotateY(Math.PI);
          sandbox.primaryWeapon.translateX(-.1);
          sandbox.primaryWeapon.translateZ(.3);
          sandbox.primaryWeapon.translateY(-.15);
          sandbox.secondaryWeapon.position.copy(weaponCamera.position);
          sandbox.secondaryWeapon.rotation.copy(weaponCamera.rotation);
          sandbox.secondaryWeapon.rotateY(Math.PI);
          sandbox.secondaryWeapon.translateX(-.1);
          sandbox.secondaryWeapon.translateZ(.3);
          sandbox.secondaryWeapon.translateY(-.15);
        }
        weaponFillLight1.position.copy(fillLight1.position);
        weaponFillLight1.rotation.copy(fillLight1.rotation);
        weaponRenderer.render(weaponScene, weaponCamera);
        sandbox.weapons.forEach(x => x.mixer && (x.mixer.update(delta), utils.options.get("Reloading") || (x.mixer.clipAction(x.animations[1]).play())));
        Object.values(sandbox.models).forEach(x => (x.mixer && (x.mixer.update(delta))));
      }
      weaponRenderer.domElement.style.position = "absolute";
      weaponRenderer.domElement.style.left = "0";
      weaponRenderer.domElement.style.top = "0";
      weaponRenderer.domElement.style.pointerEvents = "none";
      weaponRenderer.domElement.style.zIndex = "9999999999";
      weaponRenderer.setClearAlpha();
      let weaponFillLight1 = fillLight1.clone();
      let weaponDirectionalLight = directionalLight.clone();
      weaponScene.add(weaponFillLight1);
      weaponScene.add(weaponDirectionalLight);
      weaponAnimate();
	    // Performance optimization
	    renderer.shadowMap.autoUpdate = false;
	    renderer.setPixelRatio(1.2);
	    weaponRenderer.setPixelRatio(1.1);

	    // Multiplayer setup
      gametime.set("key", "pub-c-c44c8fc4-612e-4fc3-b875-4398f01da63c", "sub-c-b6832794-3c08-11ec-b2c1-a25c7fcd9558");
      gametime.set("channel", new URLSearchParams(location.search).get("lobby"));

      // Game setup
      document.addEventListener("mousedown", function(event) {
        utils.weapons.data(sandbox.currentWeapon).then(weapon => {
          if (weapon.name == "Assault_Rifle") {
            utils.options.set("RapidFire", true);
          }
          if (weapon.name == "Glock_19") {
            utils.weapons.shoot();
          }
        });
      });
      document.addEventListener("mouseup", function(event) {
        utils.options.set("RapidFire", false);
      });
      let rapidFire = setInterval(function() {
        if (utils.options.get("RapidFire")) utils.weapons.shoot();
      }, 75);
      utils.options.set("CanFire", true);
      utils.options.set("Reloading", false);
      utils.options.set("RunHealth", 100);
      utils.options.set("WeaponLocked", true);
      utils.options.set("Zoomed", false);
    </script>
  </body>
</html>