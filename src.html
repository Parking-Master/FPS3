<!DOCTYPE html>
<html lang="en">
  <head>
    <title>FPS3 Prototype</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      @font-face {
        font-family: "Roboto";
        src: url(fonts/Roboto.ttf);
      }
      html, body {
        margin: 0;
        overflow: hidden !important;
        touch-action: none !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        -khtml-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        -webkit-touch-callout: none !important;
      }
      .ui .crosshair {
        position: fixed;
        width: 40px;
        height: 40px;
        margin: 0;
        left: 50%;
        top: 50%;
        margin-left: -20px;
        margin-top: -25px;
      }
      .ui-centering, .center {
        margin: 0;
        padding: 0;
      }
      .ui img, .ui .drop-shadow {
        filter: drop-shadow(3px 3px 3px rgba(0, 0, 0, .3));
      }
      .ui .container {
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .font-size-large {
        font-size: 30px;
      }
      * {
        font-family: "Roboto", Arial;
        color: #fff;
        text-shadow: 1px 2px 3px rgba(0, 0, 0, 0.3);
      }
      .ui .primary-holder {
        position: absolute;
        left: 2%;
      }
      .ui .secondary-holder {
        position: absolute;
        left: 2%;
        bottom: 80px;
      }
      .ui .third-holder {
        position: absolute;
        left: 2%;
        bottom: 40px;
      }
      .ui .health-display {
        background: rgba(0, 0, 0, .25);
        width: 130px;
        height: 15px;
        padding: 0;
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .ui .health, .ui .run-health {
        position: relative;
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
        background: #fff;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.24);
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .ui .health span, .ui .run-health span {
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      img {
        pointer-events: none !important;
      }
      .ui .info-marker {
        position: absolute;
        width: 100%;
        left: 0;
        right: 0;
        bottom: 20px;
        visibility: hidden;
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
        z-index: 999999999;
      }
      .ui .info-marker > span {
        position: relative;
        text-align: center;
        backdrop-filter: blur(5px);
        border-radius: 5px;
        padding: 6px;
        color: #fff;
        border: .1px solid #fff;
      }
      .ui img.scope {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
        visibility: hidden;
        margin: 0;
      }
    </style>
	  <script src="https://cdn.jsdelivr.net/gh/Parking-Master/Gametime.js-2.0@latest/gametime.js"></script>
  </head>
  <body>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="js/FontLoader.min.js"></script>
    <script src="js/GLTFLoader.min.js"></script>
    <script src="js/TextGeometry.min.js"></script>
    <script src="js/fflate.min.js"></script>
    <script src="js/Capsule.min.js"></script>
    <script src="js/Octree.min.js"></script>
    <script src="https://mrgoonie.github.io/three.confetti.explosion.js/js/helper.js"></script>
    <script src="js/PointerLockControls.min.js"></script>
    <script src="js/TouchControls.min.js"></script>
    <script src="js/UI.js"></script>
    <script src="js/ExplosionConfetti.min.js"></script>
    <script src="https://unpkg.com/@seregpie/three.text-texture"></script>
    <script src="https://unpkg.com/@seregpie/three.text-sprite"></script>
    <div class="ui">
      <img class="vignette" src="images/other/blurred_border.png" style="transition: opacity .15s; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: 0; padding: 0;">
      <div class="ui-centering center">
        <img src="images/icons/ui/crosshair.png" class="crosshair drop-shadow">
      </div>
      <div class="ui-holder primary-holder holder">
        <div class="container">
          <p class="placeholder font-size-large current-grenades">0</p><img src="images/icons/ui/grenade.png" style="width: 50px"><p class="placeholder font-size-large">|</p>&ThickSpace;&ThickSpace;<p class="placeholder font-size-large current-ammo">0</p><img src="images/icons/ui/bullet.png" style="width: 50px">
        </div>
      </div>
      <div class="ui-holder secondary-holder holder">
        <div class="health-display">
          <div class="health"><span style="color: #333; display: inline-block; font-size: 12px; white-space: nowrap; display: inline-flex; text-align: center; align-items: center; justify-content: center"><img src="images/icons/heart.png" style="width: 15px"><span class="health-text" style="color: #333">100</span> %</span></div>
        </div>
      </div>
      <div class="ui-holder third-holder holder">
        <div class="health-display">
          <div class="run-health"><span style="color: #333; display: inline-block; font-size: 12px; white-space: nowrap; display: inline-flex; text-align: center; align-items: center; justify-content: center"><img src="images/icons/fast_forward.png" style="width: 20px"><span class="health-text" style="color: #333">100</span> %</span></div>
        </div>
      </div>
      <div class="info-marker"><span></span></div>
      <img class="scope">
    </div>
    <script>
	  // Game asset variables
	  otherPlayer = new THREE.Mesh();
	  space = new THREE.Mesh();
	  sun = new THREE.Mesh();
    Array.prototype.count = function() {
      let counter = 0;
      for (occurence of this) {
        if (occurence == arguments[0]) {
          counter++;
        }
      }
      return counter;
    }
    function confetti(obj) {
      let confetti = new ExplosionConfetti({
        rate: 4,
        amount: 10,
        radius: 100,
        areaWidth: 5,
        areaHeight: 0,
        fallingHeight: 1,
        fallingSpeed: 1,
        colors: [0x999999, 0xaaaaaa, 0xcfcfcf]
      });
      confetti.object.position.copy(obj.position);
      scene.add(confetti.object);
      confetti.object.scale.set(.02, .02, .02);
      let h = setInterval(() => (confetti.object.traverse((x) => (x.position.y = 0, x.material && (x.material.opacity += -.02))), confetti.update()));
      setTimeout((() => (confetti.dispose(), clearInterval(h))), 1000);
    }

	  THREE.Sound = function Sound(source = null, object = new THREE.Object3D, callback = function(sound) {}, preserve3d = true, volume = 5) {
      if (!preserve3d) {
        let sound = document.createElement("audio");
        sound.src = source;
        sound.play();
        return;
      }
	    typeof camera.getObjectByProperty("type", "AudioListener") == "undefined" && camera.add(new THREE.AudioListener());
		  let sound = new THREE.PositionalAudio(camera.getObjectByProperty("type", "AudioListener"));
		  new THREE.AudioLoader().load(source, (buffer) => {
		    sound.setBuffer(buffer);
		    sound.setRefDistance(5);
		    sound.setVolume(volume);
		    callback(sound);
		    sound.play();
		  });
		  object.add(sound);
	  }
	  utils = {
      cache: {
        options: {}
      },
      options: {
        set: function(key, value) {
          utils.cache.options[key] = value;
        },
        get: function(key) {
          return utils.cache.options[key];
        },
        defineWeapon: function(options = {}) {
          sandbox.weapons.push(options);
        }
      },
      player: {
        weapon: {
          set: function(key) {
            sandbox.weapons.forEach(x => {
              if (x.name == key) {
                let gun = x.object.getObjectByName("handR_025").children[x.object.getObjectByName("handR_025").children.length - 1].clone();
                gun.scale.set(10, 10, 10);
                gun.rotation.set(0, 0, -Math.PI / 2);
                gun.translateX(-12);
                gun.translateY(2);
                sandbox.models["player"].object.getObjectByName("mixamorigRightHand").add(gun);
              }
            });
          }
        }
      },
      camera: {
        shake: function(intensity, rate = 100) {
          let t = 0;
          let h = setInterval(() => {
            if (t >= intensity / 20) {
              return (() => {
                let t = 0;
                let h = setInterval(() => {
                  if (t >= intensity / 20) {
                    return clearInterval(h);
                  }
                  camera.rotateX(-.005);
                  t += .005;
                });
              })(), clearInterval(h);
            }
            camera.rotateX(.005);
            t += .005;
          }, 100 - rate);
        },
        zoomIn: function(o) {
          if (utils.options.get("Zoomed")) return;
          utils.options.set("Zoomed", true);
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (x.name == "Sniper_Rifle") {
              document.querySelector(".crosshair").style.visibility = "hidden";
              weaponScene.remove(sandbox.currentWeapon);
              const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
              let t = 0;
              let transition = setInterval(() => {
                t >= 65 ? clearInterval(transition) : camera.fov = e - t;
                t += 2;
                camera.updateProjectionMatrix();
              });
              document.querySelector(".ui").querySelector(".scope").src = "images/icons/ui/scope.png";
              document.querySelector(".ui").querySelector(".scope").style.visibility = "visible";
            }
            const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
            let t = 0;
            let transition = setInterval(() => {
              t >= 26 ? clearInterval(transition) : camera.fov = e - t;
              t += 2;
              camera.updateProjectionMatrix();
            });
            document.querySelector(".crosshair").src = "images/icons/ui/crosshair_zoomed.png";
            PointerControls.pointerSpeed = PointerControls.pointerSpeed / 2;
            TouchControls.speed = TouchControls.speed / 2;
            document.querySelector(".vignette").style.opacity = 0;
          });
        },
        zoomOut: function(o) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (!utils.options.get("Zoomed")) return;
            utils.options.set("Zoomed", false);
            if (x.name == "Sniper_Rifle") weaponScene.add(sandbox.currentWeapon);
            document.querySelector(".crosshair").style.visibility = "visible";
            const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
            let t = 0;
            let transition = setInterval(() => {
              t >= (x.name == "Sniper_Rifle" ? 65 : 26) ? clearInterval(transition) : camera.fov = e + t;
              t += 2;
              camera.updateProjectionMatrix();
            });
            document.querySelector(".crosshair").src = "images/icons/ui/crosshair.png";
            PointerControls.pointerSpeed = PointerControls.pointerSpeed * 2;
            TouchControls.speed = TouchControls.speed * 2;
            document.querySelector(".vignette").style.opacity = 1;
            document.querySelector(".ui").querySelector(".scope").src = "";
            document.querySelector(".ui").querySelector(".scope").style.visibility = "hidden";
          });
        }
      },
      ui: {
        infoMarker: {
          show: function(text, callback) {
            document.querySelector(".ui").querySelector(".info-marker").querySelector("span").textContent = text;
            document.querySelector(".ui").querySelector(".info-marker").style.visibility = "visible";
            if (callback) document.querySelector(".ui").querySelector(".info-marker").ontouchstart = () => callback();
          },
          hide: function() {
            document.querySelector(".ui").querySelector(".info-marker").querySelector("span").textContent = "";
            document.querySelector(".ui").querySelector(".info-marker").style.visibility = "hidden";
          }
        }
      },
	    weapons: {
        punch: function() {
          if (utils.options.get("Punching")) return;
          utils.camera.zoomOut();
          utils.options.set("Punching", true);
          setTimeout(() => utils.camera.shake(1), 200);
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            setTimeout(() => (utils.options.set("Punching", false), weapon.mixer.clipAction(weapon.animations[11]).stop()), 1500);
            let clip = weapon.mixer.clipAction(weapon.animations[11]);
            clip.loop = THREE.LoopOnce;
            clip.clampWhenFinished = true;
            clip.reset();
            clip.setDuration(.5);
            clip.play();
            setTimeout(() => (clip.timeScale = -1, clip.paused = false), 500);
          });
        },
        data: function(weapon) {
          return new Promise(function(resolve, reject) {
            sandbox.weapons.forEach(x => x.object == weapon && resolve(x));
          });
        },
        shoot: function(rounds = 1) {
          if (!utils.options.get("CanFire")) return;
          let i = 0;
          let weapon = null;
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            weapon = x;
          });
          let shooting = setInterval(() => {
            if (i >= rounds) {
              return clearInterval(shooting);
            }
            i++;
            if (weapon) {
              let cweapon = sandbox.weapons[sandbox.weapons.indexOf(weapon)];
              if (cweapon.rounds - 1 <= cweapon.minRounds) {
                utils.weapons.reload();
              }
              if (cweapon.rounds <= cweapon.minRounds) {
                return;
              }
              cweapon.rounds--;
              cweapon.roundsUsed++;
            }
            sandbox.weapons.forEach(x => x.object == sandbox.currentWeapon && (x.mixer.clipAction(x.animations[2]).reset(), x.mixer.clipAction(x.animations[2]).loop = THREE.LoopOnce, x.mixer.clipAction(x.animations[2]).reset(), x.mixer.clipAction(x.animations[2]).play(), x.mixer.clipAction(x.animations[2]).timeScale = 5, x.mixer.clipAction(x.animations[2]).fadeIn()));
            utils.camera.shake(.2);
            let e = new THREE.Mesh(new THREE.CircleGeometry(.1, 20));
            e.position.copy(camera.position);
            e.rotation.copy(camera.rotation);
            e.updateMatrix();
            let hole = new THREE.SpotLight(100, 0x999999, 10000);
            let objects = utils.options.get("TempObjects");
            objects.push(hole);
            if (objects.length > 10) (scene.remove(objects[0]), objects.shift());
            utils.options.set("TempObjects", objects);
            let h = setInterval(() => {
              map.traverse((x) => {
                if (x.isObject3D && ((!x.name.includes("scene") && !x.name.includes("Scene")) && collision(e, x))) {
                  return setTimeout(() => (scene.remove(hole), delete e, delete hole), 10000), scene.add(hole), hole.color = 0x999999, hole.penumbra = .1, hole.angle = .003, hole.position.copy(e.position), hole.target = e, hole.rotation.copy(e.rotation), hole.translateZ(1), e.material = new THREE.MeshPhongMaterial({ opacity: 0, side: THREE.DoubleSide }), clearInterval(h);
                }
                e.translateZ(-.02);
              });
            }, 10);
            if (weapon.name == "Sniper_Rifle" && utils.options.get("Zoomed")) {
              utils.camera.shake(1);
            }
            let flash = sandbox.models["flash"].object;
            new THREE.Sound("sounds/guns/" + weapon.name + "/fire.mp3", sandbox.currentWeapon, () => {}, false);
            flash.children[0].material.opacity = 1;
            flash.scale.set(.1, .1, .1);
            flash.position.copy(sandbox.currentWeapon.position);
            flash.rotation.copy(sandbox.currentWeapon.rotation);
            flash.translateY(.11);
            flash.rotateY(Math.PI);
            flash.translateX(.08);
            flash.translateZ(-.3);
            let sticky = setInterval(() => {
              flash.position.copy(sandbox.currentWeapon.position);
              flash.rotation.copy(sandbox.currentWeapon.rotation);
              flash.translateY(.11);
              flash.rotateY(Math.PI);
              flash.translateX(.08);
              flash.translateZ(-.3);
            });
            let shell = sandbox.models["shell"].object;
            shell.position.copy(sandbox.currentWeapon.position);
            shell.rotation.copy(sandbox.currentWeapon.rotation);
            shell.scale.copy(sandbox.currentWeapon.scale);
            weaponScene.add(shell);
            let effect = setInterval(() => {
              shell.translateX(-.07);
              shell.position.y += -.03;
            });
            setTimeout(() => (weaponScene.remove(shell), clearInterval(effect)), 1000);
            let light = new THREE.PointLight(0xf99c00, 1, 4, 3);
            light.position.copy(flash.position);
            light.rotation.copy(flash.rotation);
            weaponScene.add(flash);
            scene.add(light);
            let lightClone = light.clone();
            weaponScene.add(lightClone);
            document.querySelector(".crosshair").style.transition = "transform .05s ease-out", document.querySelector(".crosshair").style.transform = "scale(1.15)", setTimeout(() => document.querySelector(".crosshair").style.transform = "", 100);
            setTimeout(() => (weaponScene.remove(flash), weaponScene.remove(lightClone), scene.remove(light), clearInterval(sticky)), 25);
          }, 60);
        },
        pickup: function(weapon) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            let e = sandbox.models[x.name].object.clone();
            scene.add(e);
            e.scale.set(.1, .1, .1);
            e.position.set(camera.position.x, camera.position.y - 1, camera.position.z);
            let boxes = utils.options.get("WeaponBoxes");
            let clone = boxes;
            let weaponArray = [];
            Object.keys(clone).forEach(x => {
              x = x.replace(/\-[0-9]/gi, "");
              weaponArray.push(x);
            });
            weaponArray.push(x.name);
            let id = weaponArray.count(x.name);
            let newWeapon = x.name + "-" + id;
            boxes[newWeapon] = e;
            utils.options.set("WeaponBoxes", boxes);
            let h = setInterval(() => {
              if (camera.position.distanceTo(e.position) <= 2) {
                utils.options.set("TouchingWeapon", e);
                if (sandbox.loadout.indexOf(x.name) > -1) {
                  let position = sandbox.currentWeapon == sandbox.primaryWeapon ? 0 : 1;
                  sandbox.weapons.forEach(i => {
                    if (i.name == x.name) {
                      i.maxClips += x.clips;
                      i.clips += x.clips;
                      let boxes = utils.options.get("WeaponBoxes");
                      boxes[newWeapon].position.y = -10000;
                      scene.remove(boxes[newWeapon]);
                      delete boxes[newWeapon];
                      utils.options.set("WeaponBoxes", boxes);
                      clearInterval(h);
                      utils.ui.infoMarker.hide();
                    }
                  });
                }
                if (utils.options.get("TouchDevice")) {
                  utils.ui.infoMarker.show("Hold to pick up " + x.name.replace("_", " "), () => {
                    document.dispatchEvent(new KeyboardEvent("keydown", { key: "t", code: "KeyT" }));
                    document.dispatchEvent(new KeyboardEvent("keyup", { key: "t", code: "KeyT" }));
                  });
                } else {
                  utils.ui.infoMarker.show("Hold [T] to pick up " + x.name.replace("_", " "));
                }
              } else {
                utils.options.get("TouchingWeapon") == e && utils.options.set("TouchingWeapon", null);
                !utils.options.get("TouchingWeapon") && utils.ui.infoMarker.hide();
              }
            });
            document.addEventListener("keydown", function(event) {
              if (event.key == "t" && camera.position.distanceTo(e.position) <= 2) {
                utils.weapons.pickup(newWeapon);
                let boxes = utils.options.get("WeaponBoxes");
                delete boxes[newWeapon];
                utils.options.set("WeaponBoxes", boxes);
                clearInterval(h);
                utils.ui.infoMarker.hide();
              }
            });
          });
          let weaponBox = utils.options.get("WeaponBoxes")[weapon];
          scene.remove(weaponBox);
          weaponBox.position.y = -10000;
          let newWeapon = null;
          sandbox.weapons.forEach(x => {
            if (weapon.includes(x.name)) {
              newWeapon = x;
              weaponScene.remove(sandbox.currentWeapon);
              let position = sandbox.currentWeapon == sandbox.primaryWeapon ? 0 : 1;
              sandbox.loadout[position] = newWeapon.name;
              position == 0 ? sandbox.primaryWeapon = newWeapon.object : sandbox.secondaryWeapon = newWeapon.object;
              utils.weapons.switch();
              sandbox.currentWeapon != x.object && utils.weapons.switch();
            }
          });
        },
        create: function(weapon = "", pos = new THREE.Vector3()) {
          let box = new THREE.Object3D();
          new THREE.GLTFLoader().load("models/assets/pointer.glb", function(pointer) {
            pointer = pointer.scene;
            pointers.push(pointer);
            let boxName = null;
            let newWeapon;
            new THREE.GLTFLoader().load("models/assets/weapon_box.glb", function(gltf) {
              box = gltf.scene;
              box.scale.set(.01, .01, .01);
              box.position.set(pos.x, pos.y, pos.z);
              scene.add(box);
              let boxes = utils.options.get("WeaponBoxes");
              let clone = boxes;
              let weaponArray = [];
              Object.keys(clone).forEach(x => {
                x = x.replace(/\-[0-9]/gi, "");
                weaponArray.push(x);
              });
              weaponArray.push(weapon);
              let id = weaponArray.count(weapon);
              newWeapon = weapon + "-" + id;
              boxName = newWeapon;
              boxes[newWeapon] = box;
              pointer.position.copy(box.position);
              weaponScene.add(pointer);
              utils.options.set("WeaponBoxes", boxes);
            });
            let h = setInterval(() => {
              if (camera.position.distanceTo(box.position) <= 2) {
                utils.options.set("TouchingWeapon", box);
                if (sandbox.loadout.indexOf(weapon) > -1) {
                  let position = sandbox.loadout.indexOf(weapon);
                  utils.weapons.data(position == 0 ? sandbox.primaryWeapon : sandbox.secondaryWeapon).then(x => {
                    sandbox.weapons.forEach(i => {
                      if (i.name == weapon) {
                        i.maxClips += x.clips;
                        i.clips += x.clips;
                        let boxes = utils.options.get("WeaponBoxes");
                        boxes[newWeapon].position.y = -10000;
                        scene.remove(boxes[newWeapon]);
                        delete boxes[newWeapon];
                        utils.options.set("WeaponBoxes", boxes);
                        clearInterval(h);
                        utils.ui.infoMarker.hide();
                      }
                    });
                  });
                }
                utils.ui.infoMarker.show("Hold [T] to pick up " + weapon.replace("_", " "));
              } else {
                utils.options.get("TouchingWeapon") == box && utils.options.set("TouchingWeapon", null);
                !utils.options.get("TouchingWeapon") && utils.ui.infoMarker.hide();
              }
            });
            document.addEventListener("keydown", function(event) {
              if (event.key == "t" && camera.position.distanceTo(box.position) <= 2) {
                utils.weapons.pickup(boxName);
                let boxes = utils.options.get("WeaponBoxes");
                delete boxes[boxName];
                utils.options.set("WeaponBoxes", boxes);
                clearInterval(h);
                utils.ui.infoMarker.hide();
              }
            });
          });
        },
		    switch: function() {
          utils.camera.zoomOut();
		    	let newWeapon;
		    	let oldWeapon = sandbox.currentWeapon;
		      if (sandbox.currentWeapon == sandbox.primaryWeapon)
		  	    newWeapon = sandbox.secondaryWeapon;
		  	  else newWeapon = sandbox.primaryWeapon;
		  	  weaponScene.remove(oldWeapon);
		  	  sandbox.currentWeapon = newWeapon;
		  	  sandbox.weapons.forEach(x => {
		  	    if (!(x.object == sandbox.currentWeapon)) return;
		  	    x.mixer.clipAction(x.animations[0]).reset();
		  	    x.mixer.clipAction(x.animations[0]).loop = THREE.LoopOnce;
		  	    x.mixer.clipAction(x.animations[0]).play();
		  	  });
		  	  weaponScene.add(sandbox.currentWeapon);
		    },
		    reload: function() {
          if (utils.options.get("Reloading")) return;
          utils.camera.zoomOut();
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            if (weapon.clips <= weapon.minClips) return;
            utils.options.set("CanFire", false);
            utils.options.set("Reloading", true);
            keyStates["ShiftLeft"] = false;
            weapon.mixer.clipAction(weapon.animations[1]).stop();
            weapon.mixer.clipAction(weapon.animations[6]).stop();
            weapon.mixer.clipAction(weapon.animations[7]).stop();
            weapon.roundsUsed += weapon.rounds;
            if (weapon.rounds <= 0) {
              new THREE.Sound("sounds/guns/" + weapon.name + "/full.mp3");
              let index = weapon.reloads.full.useDefaultAnimation ? 4 : 5;
              weapon.mixer.clipAction(weapon.animations[index]).timeScale = 2.5;
              weapon.mixer.clipAction(weapon.animations[index]).loop = THREE.LoopOnce;
              weapon.mixer.clipAction(weapon.animations[index]).reset();
              weapon.mixer.clipAction(weapon.animations[index]).play();
            } else {
              new THREE.Sound("sounds/guns/" + weapon.name + "/easy.mp3");
              weapon.mixer.clipAction(weapon.animations[3]).timeScale = 2.5;
              weapon.mixer.clipAction(weapon.animations[3]).loop = THREE.LoopOnce;
              weapon.mixer.clipAction(weapon.animations[3]).reset();
              weapon.mixer.clipAction(weapon.animations[3]).play();
            }
            setTimeout(() => {
              sandbox.weapons[sandbox.weapons.indexOf(weapon)].rounds = sandbox.weapons[sandbox.weapons.indexOf(weapon)].maxRounds;
              sandbox.weapons[sandbox.weapons.indexOf(weapon)].clips--;
              utils.options.set("CanFire", true);
              utils.options.set("Reloading", false);
              if ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"])) {
                weapon.mixer.clipAction(weapon.animations[6]).play();
              }
            }, weapon.rounds <= 0 ? weapon.reloads.full.time : weapon.reloads.easy.time);
          });
        },
        unlock: function() {
          utils.options.set("WeaponLocked", false);
        },
        lock: function() {
          utils.options.set("WeaponLocked", true);
        },
        grenades: {
          throw: function() {
            if (sandbox.grenades.current <= sandbox.grenades.min) {
              return;
            }
            if (utils.options.get("Punching")) return;
            utils.options.set("Punching", true);
            utils.camera.zoomOut();
            utils.weapons.data(sandbox.currentWeapon).then(weapon => {
              setTimeout(() => (utils.options.set("Punching", false), weapon.mixer.clipAction(weapon.animations[10]).stop()), 500);
              let clip = weapon.mixer.clipAction(weapon.animations[10]);
              let clipFrom = weapon.mixer.clipAction(weapon.animations[1]);
              clip.loop = THREE.LoopOnce;
              clip.reset();
              clip.setDuration(.5);
              clip.play();
              clip.crossFadeFrom(clipFrom);
            });
            sandbox.grenades.current--;
            setTimeout(() => utils.camera.shake(.5), 100);
            const sphere = spheres[sphereIdx];
            camera.getWorldDirection(playerDirection);
            sphere.collider.center.copy(playerCollider.end).addScaledVector(playerDirection, playerCollider.radius * 1.5);
            const impulse = 15 + 30 * (1 - Math.exp((mouseTime - performance.now()) * 0.001));
            sphere.velocity.copy(playerDirection).multiplyScalar(impulse);
            sphere.velocity.addScaledVector(playerVelocity, 2);
            sphereIdx = (sphereIdx + 1) % spheres.length;
            !(scene.children.indexOf(sphere.mesh) > -1) && scene.add(sphere.mesh);
            let collided = setInterval(() => {
              if (worldOctree.sphereIntersect(sphere.collider)) {
                setTimeout(() => {
                  utils.explosion(sphere.mesh);
                  scene.remove(sphere.mesh);
                  new THREE.Sound("sounds/explosion.mp3", sphere.mesh, () => {}, true, 20);
                  sphere.hits = 0;
                }, 1000);
                clearInterval(collided);
              }
            });
          }
        }
		  },
      explosion: function(obj) {
        let explosion = sandbox.models["explosion"];
        let mixer = explosion.mixer.clipAction(explosion.animations[0]);
        mixer.reset();
        mixer.loop = THREE.LoopOnce;
        mixer.clampWhenFinished = true;
        mixer.play();
        let light = new THREE.PointLight(0xbb3905, 1);
        let lightClone = light.clone();
        explosion = explosion.object;
        explosion.traverse(x => {
          if (!x.material) return;
          x.material.transparent = true;
          x.material.opacity = 1;
        });
        scene.add(explosion);
        explosion.position.copy(obj.position);
        explosion.scale.set(.2, .2, .2);
        scene.add(light);
        light.position.copy(obj.position);
        weaponScene.add(lightClone);
        let fadeIn = setInterval(() => {
          if (explosion.scale.x >= 3) {
            clearInterval(fadeIn);
          } else {
            let increment = .05;
            explosion.scale.set(explosion.scale.x + increment, explosion.scale.y + increment, explosion.scale.z + increment);
          }
        });
        let smoke = sandbox.models["smoke"];
        smoke.object.scale.set(5, 5, 5);
        smoke.object.traverse(x => x.frustumCulled = false);
        let smokeClip = smoke.mixer.clipAction(smoke.animations[0]);
        smoke.object.position.copy(explosion.position);
        smokeClip.reset();
        smokeClip.loop = THREE.LoopOnce;
        smokeClip.clampWhenFinished = true;
        smokeClip.play();
        smoke.object.traverse(x => (x.material && (x.material.opacity = 0)));
        scene.add(smoke.object);
        setTimeout(() => {
          let fadeOut = setInterval(() => {
            smoke.object.traverse(x => (x.material && (x.material.transparent = true, x.material.opacity >= .02 || (x.material.opacity += .001))));
            explosion.traverse(x => {
              if (!x.material) return;
              x.material.transparent = true;
              if (x.material.opacity <= 0) {
                scene.remove(light);
                weaponScene.remove(lightClone);
                scene.remove(x);
                clearInterval(fadeOut);
              } else {
                x.material.opacity += -.01;
                light.intensity <= 0 ? light.intensity = 0 : light.intensity += -.01;
                lightClone.intensity <= 0 ? lightClone.intensity = 0 : lightClone.intensity += -.01;
              }
            });
          });
        }, 500);
        (() => {
          document.querySelector(".vignette").style.filter = "invert(" + (100 - camera.position.distanceTo(explosion.position).toFixed(0)) + "%)"
          let t = (100 - camera.position.distanceTo(explosion.position).toFixed(0));
          let h = setInterval(() => {
            if (t <= 0) {
              return document.querySelector(".vignette").style.filter = "", clearInterval(h);
            }
            t--;
            document.querySelector(".vignette").style.filter = "invert(" + t + "%)"
          });
        })();
        setTimeout(() => scene.remove(explosion), 2000);
        setTimeout(() => scene.remove(smoke.object), 15000);
      }
	  };
      sandbox = {
        map: new URLSearchParams(location.search).get("map") || "Cargo",
        loadout: ["Assault_Rifle", "Glock_19"],
        weapons: [
          {
            name: "Assault_Rifle",
            rounds: 56,
            minRounds: 0,
            maxRounds: 56,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2500,
                useDefaultAnimation: true
              }
            }
          },
          {
            name: "Glock_19",
            rounds: 12,
            minRounds: 0,
            maxRounds: 12,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 1500
              },
              full: {
                sound: null,
                time: 2000,
                useDefaultAnimation: true
              }
            }
          },
          {
            name: "Sniper_Rifle",
            rounds: 6,
            minRounds: 0,
            maxRounds: 6,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 2500
              },
              full: {
                sound: null,
                time: 2750,
                useDefaultAnimation: false
              }
            }
          },
          {
            name: "Micro_Uzi",
            rounds: 36,
            minRounds: 0,
            maxRounds: 36,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 1500
              },
              full: {
                sound: null,
                time: 1750,
                useDefaultAnimation: true
              }
            }
          },
          {
            name: "Auto_Pistol",
            rounds: 50,
            minRounds: 0,
            maxRounds: 50,
            minClips: 0,
            maxClips: 2,
            clips: 2,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2250,
                useDefaultAnimation: true
              }
            }
          },
        ],
        grenades: {
          min: 0,
          max: 2,
          current: 2,
          types: ["hand"]
        },
        currentWeapon: null,
        primaryWeapon: null,
        secondaryWeapon: null,
        models: {
          "grenade": {
            srcPath: "models/weapons/grenades/hand.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "flash": {
            srcPath: "models/assets/muzzle_flash.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "shell": {
            srcPath: "models/assets/bullet_shell.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "player": {
            srcPath: "models/characters/Steve/scene.gltf",
            object: null,
            callback: function(model) {
              model.scale.set(.75, .75, .75);
              scene.add(model);
              model.traverse(x => x.frustumCulled = false);
              model.position.set(17, 0, -2.25);
            },
            mixer: null,
            animations: null
          },
          "Assault_Rifle": {
            srcPath: "models/weapons/dropped/Assault_Rifle.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Glock_19": {
            srcPath: "models/weapons/dropped/Glock_19.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Sniper_Rifle": {
            srcPath: "models/weapons/dropped/Sniper_Rifle.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Micro_Uzi": {
            srcPath: "models/weapons/dropped/Micro_Uzi.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Auto_Pistol": {
            srcPath: "models/weapons/dropped/Auto_Pistol.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "explosion": {
            srcPath: "models/assets/timeframe_explosion.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "smoke": {
            srcPath: "models/assets/smoke_cloud.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "pointer": {
            srcPath: "models/assets/pointer.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          }
        }
      };
      const clock = new THREE.Clock();
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.rotation.order = "YXZ";
      const fillLight1 = new THREE.HemisphereLight(0x4488bb, 0x002244, 0.5);
      fillLight1.position.set(2, 1, 1);
      scene.add(fillLight1);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(-5, 25, -1);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.near = 0.01;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.right = 30;
      directionalLight.shadow.camera.left = -30;
      directionalLight.shadow.camera.top = 30;
      directionalLight.shadow.camera.bottom = -30;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.radius = 4;
      directionalLight.shadow.bias = -0.00006;
      scene.add(directionalLight);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.VSMShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.body.appendChild(renderer.domElement);
      let GRAVITY = 60;
      let NUM_SPHERES = 2;
      let SPHERE_RADIUS = 0.2;
      let STEPS_PER_FRAME = 10;
      const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
      const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xbbbb44 });
      const spheres = [];
      let sphereIdx = 0;
      for (let i = 0; i < NUM_SPHERES; i++) {
        let loader = setInterval(() => {
          if (sandbox.models["grenade"].object != null && spheres.length < 2) {
            const sphere = sandbox.models["grenade"].object.clone();
            if (sphere) {
              scene.add(sphere);
              spheres.push({
                mesh: sphere,
                collider: new THREE.Sphere(new THREE.Vector3(0, - 100, 0), SPHERE_RADIUS),
                velocity: new THREE.Vector3()
              });
            }
            clearInterval(loader);
          }
        });
      }
      const worldOctree = new THREE.Octree();
      const playerCollider = new THREE.Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1, 0), 0.35);
      playerCollider.start.set(13.5, 0.35, -18.5);
      playerCollider.end.set(13.5, 1, -18.5);
      playerCollider.radius = 0.35;
      camera.position.copy(playerCollider.end);
      camera.rotation.set(0,Math.PI,0);
      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();
      let playerOnFloor = false;
      let mouseTime = 0;
      const keyStates = {};
      const vector1 = new THREE.Vector3();
      const vector2 = new THREE.Vector3();
      const vector3 = new THREE.Vector3();
      document.addEventListener("keydown", (event) => {
        keyStates[event.code] = true;
        if (keyStates["ShiftLeft"] && ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"]))) {
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("RunHealth") <= 0 ? (weapon.mixer.clipAction(weapon.animations[7]).play(), weapon.mixer.clipAction(weapon.animations[7]).reset(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[7]), .4), keyStates["ShiftLeft"] = false) : utils.options.set("RunHealth", utils.options.get("RunHealth") - 2);
          });
        }
        if ((keyStates["KeyW"] || keyStates["ArrowUp"]) && !event.repeat) {
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            if (keyStates["ShiftLeft"]) {
              utils.options.get("Reloading") || (weapon.mixer.clipAction(weapon.animations[6]).crossFadeTo(weapon.mixer.clipAction(weapon.animations[7]), .4), weapon.mixer.clipAction(weapon.animations[7]).reset(), weapon.mixer.clipAction(weapon.animations[7]).play());
            } else {
              utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
            }
          });
        }
        if (keyStates["KeyR"] && !event.repeat) {
          utils.weapons.reload();
        }
        if (keyStates["KeyI"] && !event.repeat) {
          utils.options.get("Zoomed") ? utils.camera.zoomOut() : utils.camera.zoomIn();
        }
        if (keyStates["KeyB"] && !event.repeat) {
          utils.weapons.punch();
        }
        if (keyStates["KeyF"] && !event.repeat) {
          document.dispatchEvent(new MouseEvent("mousedown"));
        }
        if (keyStates["KeyY"] && !event.repeat) {
          utils.weapons.switch();
        }
        if (keyStates["KeyM"] && !event.repeat) {
          utils.weapons.grenades.throw();
        }
      });
      document.addEventListener("keyup", (event) => {
        clearInterval(utils.options.get("Bobbing"));
        utils.options.set("Bobbing", null);
        sandbox.weapons.forEach(weapon => {
          weapon.mixer.clipAction(weapon.animations[6]).stop(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[7]), .4), weapon.mixer.clipAction(weapon.animations[7]).play();
          if ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"])) {
            weapon.mixer.clipAction(weapon.animations[6]).stop();
          }
          if (keyStates["KeyF"]) {
            document.dispatchEvent(new MouseEvent("mouseup"));
          }
        });
        keyStates[event.code] = false;
      });
      renderer.domElement.addEventListener("mousedown", () => {
        if (document.pointerLockElement != null) return;
        document.body.requestPointerLock();
        PointerControls.lock();
        mouseTime = performance.now();
      });
      document.addEventListener("mouseup", () => {
        PointerControls.lock();
      });
      document.body.addEventListener("mousemove", (event) => { });
      window.addEventListener("resize", onWindowResize);
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        weaponCamera.aspect = window.innerWidth / window.innerHeight;
        weaponCamera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        weaponRenderer.setSize(window.innerWidth, window.innerHeight);
      }
      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;
        if (result) {
          playerOnFloor = result.normal.y > 0;
          if (!playerOnFloor) {
            playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
          }
          playerCollider.translate(result.normal.multiplyScalar(result.depth));
        }
      }
      function updatePlayer(deltaTime) {
        let damping = Math.exp(- 4 * deltaTime) - 1;
        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * (deltaTime);
          damping *= 0.1;
        }
        playerVelocity.addScaledVector(playerVelocity, damping);
        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);
        playerCollisions();
        camera.position.copy(playerCollider.end);
      }
      function playerSphereCollision(sphere) {
        const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);
        const sphere_center = sphere.collider.center;
        const r = playerCollider.radius + sphere.collider.radius;
        const r2 = r * r;
        for (const point of [playerCollider.start, playerCollider.end, center]) {
          const d2 = point.distanceToSquared(sphere_center);
          if (d2 < r2) {
            const normal = vector1.subVectors(point, sphere_center).normalize();
            const v1 = vector2.copy(normal).multiplyScalar(normal.dot(playerVelocity));
            const v2 = vector3.copy(normal).multiplyScalar(normal.dot(sphere.velocity));
            playerVelocity.add(v2).sub(v1);
            sphere.velocity.add(v1).sub(v2);
            const d = (r - Math.sqrt(d2)) / 2;
            sphere_center.addScaledVector(normal, - d);
          }
        }
      }
      function spheresCollisions() {
        for (let i = 0, length = spheres.length; i < length; i++) {
          const s1 = spheres[i];
          for (let j = i + 1; j < length; j++) {
            const s2 = spheres[j];
            const d2 = s1.collider.center.distanceToSquared(s2.collider.center);
            const r = s1.collider.radius + s2.collider.radius;
            const r2 = r * r;
            if (d2 < r2) {
              const normal = vector1.subVectors(s1.collider.center, s2.collider.center).normalize();
              const v1 = vector2.copy(normal).multiplyScalar(normal.dot(s1.velocity));
              const v2 = vector3.copy(normal).multiplyScalar(normal.dot(s2.velocity));
              s1.velocity.add(v2).sub(v1);
              s2.velocity.add(v1).sub(v2);
              const d = (r - Math.sqrt(d2)) / 2;
              s1.collider.center.addScaledVector(normal, d);
              s2.collider.center.addScaledVector(normal, - d);
            }
          }
        }
      }
      function updateSpheres(deltaTime) {
        spheres.forEach(sphere => {
          sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);
          const result = worldOctree.sphereIntersect(sphere.collider);
          if (result) {
            sphere.hits || (sphere.hits = 0);
            if (scene.children.indexOf(sphere.mesh) > -1 && sphere.hits < 4) {
              let hits = ["ricochet1", "ricochet2", "ricochet3"];
              sphere.hits++;
              new THREE.Sound("sounds/" + hits[Math.floor(Math.random() * hits.length)] + ".mp3", sphere.mesh);
            }
            sphere.velocity.addScaledVector(result.normal, - result.normal.dot(sphere.velocity) * 1.5);
            sphere.collider.center.add(result.normal.multiplyScalar(result.depth));
          } else {
            sphere.velocity.y -= (GRAVITY * deltaTime + .01);
          }
          const damping = Math.exp(- 1.5 * deltaTime) - 1.003;
          sphere.velocity.addScaledVector(sphere.velocity, damping);
          playerSphereCollision(sphere);
        });
        spheresCollisions();
        for (const sphere of spheres) {
          sphere.mesh.position.copy(sphere.collider.center);
        }
      }
      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }
      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }
      function collision(e, B) {
        let firstBB = new THREE.Box3().setFromObject(e);
        let secondBB = new THREE.Box3().setFromObject(B);
        return firstBB.intersectsBox(secondBB)
      }
      const loader = new THREE.GLTFLoader();
      loader.load("models/maps/" + sandbox.map + ".glb", (gltf) => {
        map = gltf.scene;
        worldOctree.fromGraphNode(gltf.scene);
        scene.add(gltf.scene);
        gltf.scene.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material.map) {
              child.material.map.anisotropy = 4;
            }
          }
        });
        function isSustained() {
          return new Promise(function(resolve, reject) {
            let t = camera.position;
            setTimeout(() => t.y - .02 >= camera.position.y ? resolve(!true) : resolve(!false), 100);
          });
        }
        let animated = false;
        let checkSustained = setInterval(() => {
          isSustained().then(sustained => {
            if (sustained) {
              !animated && animate();
              animated = true;
              clearInterval(checkSustained);
            }
          });
        });
        updateShadows();
      });
      function updateShadows() {
        renderer.shadowMap.needsUpdate = true;
      }
      function teleportPlayerIfOob() {
        if (camera.position.y <= -25) {
          playerCollider.start.set(13.5, 0.35, -18.5);
          playerCollider.end.set(13.5, 1, -18.5);
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0,Math.PI,0);
        }
      }
      function controls(deltaTime) {
        const speedDelta = .025;
        if (keyStates["KeyW"] || keyStates["ArrowUp"]) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
          });
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getForwardVector().multiplyScalar(keyStates["ShiftLeft"] ? speedDelta + .05 : speedDelta));
        }
        if (keyStates["KeyS"] || keyStates["ArrowDown"]) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
          });
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
        }
        if (keyStates["KeyA"] || keyStates["ArrowLeft"]) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
          });
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
        }
        if (keyStates["KeyD"] || keyStates["ArrowRight"]) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
          });
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
        }
        if (playerOnFloor) {
          if (keyStates["Space"]) {
            playerVelocity.y = 10;
          }
        }
      }
      function animate() {
        requestAnimationFrame(animate);
        sun.position.set(camera.position.x, 50, camera.position.z);
        utils.options.get("RunHealth") >= 100 ? utils.options.set("RunHealth", 100) : keyStates["ShiftLeft"] || utils.options.set("RunHealth", utils.options.get("RunHealth") + 1);
        document.querySelector(".run-health").style.width = (utils.options.get("RunHealth") <= 0 ? 0 : utils.options.get("RunHealth")) + "%";
        document.querySelector(".run-health").querySelector("span").querySelector("span").textContent = (utils.options.get("RunHealth") <= 0 ? 0 : utils.options.get("RunHealth"));
        document.querySelector(".current-grenades").textContent = sandbox.grenades.current;
        sandbox.currentWeapon && utils.weapons.data(sandbox.currentWeapon).then(weapon => {
          document.querySelector(".current-ammo").textContent = (weapon.maxRounds * (weapon.maxClips + 1)) - weapon.roundsUsed;
        });
        if (sandbox.primaryWeapon != null && sandbox.secondaryWeapon != null && utils.options.get("WeaponLocked")) {
          sandbox.primaryWeapon.position.copy(camera.position);
          sandbox.primaryWeapon.rotation.copy(camera.rotation);
          sandbox.primaryWeapon.rotateY(Math.PI);
          sandbox.primaryWeapon.translateX(-.1);
          sandbox.primaryWeapon.translateZ(.3);
          sandbox.primaryWeapon.translateY(-.15);
          sandbox.secondaryWeapon.position.copy(camera.position);
          sandbox.secondaryWeapon.rotation.copy(camera.rotation);
          sandbox.secondaryWeapon.rotateY(Math.PI);
          sandbox.secondaryWeapon.translateX(-.1);
          sandbox.secondaryWeapon.translateZ(.3);
          sandbox.secondaryWeapon.translateY(-.15);
        }
        const deltaTime = clock.getDelta();
        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          controls(deltaTime);
          updatePlayer(deltaTime);
          updateSpheres(deltaTime);
          teleportPlayerIfOob();
        }
        renderer.render(scene, camera);
      }
      sandbox.weapons.forEach(x => {
        new THREE.GLTFLoader().load(`models/weapons/${x.name}.glb`, (model) => {
          x.object = model.scene;
          x.object.scale.set(.01, .01, .01);
          x.animations = model.animations;
          x.mixer = new THREE.AnimationMixer(model.scene);
          x.roundsUsed = 0;
          let weapon = x;
          weapon.mixer.clipAction(weapon.animations[6]).stop(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[7]), .4), weapon.mixer.clipAction(weapon.animations[7]).play();
          if (x.name == sandbox.loadout[0]) {
            sandbox.primaryWeapon = x.object;
            sandbox.currentWeapon = x.object;
            weaponScene.add(sandbox.primaryWeapon);
          }
          if (x.name == sandbox.loadout[1]) {
            sandbox.secondaryWeapon = x.object;
          }
        });
      });
      Object.keys(sandbox.models).forEach(x => {
        new THREE.GLTFLoader().load(sandbox.models[x].srcPath, (model) => {
          sandbox.models[x].object = model.scene;
          sandbox.models[x].mixer = new THREE.AnimationMixer(model.scene);
          sandbox.models[x].animations = model.animations;
          sandbox.models[x].callback(model.scene);
        });
      });
      const weaponRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      weaponRenderer.setPixelRatio(window.devicePixelRatio);
      weaponRenderer.setSize(window.innerWidth, window.innerHeight);
      weaponRenderer.outputEncoding = THREE.sRGBEncoding;
      weaponRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.body.appendChild(weaponRenderer.domElement);
      const weaponScene = new THREE.Scene();
      const weaponCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      const PointerControls = new PointerLockControls(camera, renderer.domElement);
      const TouchControls = new THREE.TouchControls(camera, renderer.domElement);
      PointerControls.isLocked = true;
      TouchControls.speed = 3;
      weaponCamera.rotation.order = "YXZ";
      let pointers = [];
      function weaponAnimate() {
        const delta = clock.getDelta();
        requestAnimationFrame(weaponAnimate);
        pointers.forEach(x => {
          let k = (camera.position.distanceTo(x.position) > 4 ? 4 : camera.position.distanceTo(x.position)) / 100;
          x.scale.set(k, k, k);
          x.lookAt(camera.position);
        });
        space.position.copy(camera.position);
        space.rotateY(.00025);
        space.rotateX(.0001);
        sun.position.set(camera.position.x, 50, camera.position.z);
        weaponCamera.position.copy(camera.position);
        weaponCamera.rotation.copy(camera.rotation);
        if (sandbox.primaryWeapon != null && sandbox.secondaryWeapon != null && utils.options.get("WeaponLocked")) {
          sandbox.primaryWeapon.position.copy(weaponCamera.position);
          sandbox.primaryWeapon.rotation.copy(weaponCamera.rotation);
          sandbox.primaryWeapon.rotateY(Math.PI);
          sandbox.primaryWeapon.translateX(-.1);
          sandbox.primaryWeapon.translateZ(.3);
          sandbox.primaryWeapon.translateY(-.15);
          sandbox.secondaryWeapon.position.copy(weaponCamera.position);
          sandbox.secondaryWeapon.rotation.copy(weaponCamera.rotation);
          sandbox.secondaryWeapon.rotateY(Math.PI);
          sandbox.secondaryWeapon.translateX(-.1);
          sandbox.secondaryWeapon.translateZ(.3);
          sandbox.secondaryWeapon.translateY(-.15);
        }
        weaponFillLight1.position.copy(fillLight1.position);
        weaponFillLight1.rotation.copy(fillLight1.rotation);
        weaponRenderer.render(weaponScene, weaponCamera);
        sandbox.weapons.forEach(x => x.mixer && (x.mixer.update(delta), utils.options.get("Reloading") || (x.mixer.clipAction(x.animations[1]).play())));
        Object.values(sandbox.models).forEach(x => (x.mixer && (x.mixer.update(delta))));
      }
      weaponRenderer.domElement.style.position = "absolute";
      weaponRenderer.domElement.style.left = "0";
      weaponRenderer.domElement.style.top = "0";
      weaponRenderer.domElement.style.pointerEvents = "none";
      weaponRenderer.domElement.style.zIndex = "9999";
      weaponRenderer.setClearAlpha();
      weaponRenderer.setClearColor(0x000000, 0);
      let weaponFillLight1 = fillLight1.clone();
      let weaponDirectionalLight = directionalLight.clone();
      weaponScene.add(weaponFillLight1);
      weaponScene.add(weaponDirectionalLight);
      weaponAnimate();
	    // Performance optimization
	    renderer.shadowMap.autoUpdate = false;
	    renderer.setPixelRatio(1.2);
	    weaponRenderer.setPixelRatio(1.1);

	    // Multiplayer setup
      gametime.set("key", "pub-c-1ed2f84f-762b-4211-84f9-617b19be2b23", "sub-c-1521e0cc-f132-41e5-9d46-6b06a7d09f90");
      gametime.set("channel", new URLSearchParams(location.search).get("lobby"));

      // Game setup
      if (sandbox.map == "Cargo") {
        sun = new THREE.Mesh(new THREE.CircleGeometry(10), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/sun.png"), transparent: true }));
        scene.background = new THREE.Color(0x88ccee);
        sun.position.set(0, 50, 0);
        sun.rotateX(1);
        scene.add(sun);
        scene.fog = new THREE.Fog(0x88ccee, 0, 100);
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(10, 0, -8));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(9.5, 0, -16));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(14, 0, 1.5));
      } else if (sandbox.map == "Storage") {
        sun = new THREE.Mesh(new THREE.CircleGeometry(10), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/sun.png"), transparent: true }));
        scene.background = new THREE.Color(0x88ccee);
        sun.position.set(0, 50, 0);
        sun.rotateX(1);
        scene.add(sun);
        scene.fog = new THREE.Fog(0xffffff, 0, 90);
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(-3.5, 0, 16));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(-7, 0, -4.5));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(-7, 3.8, 20));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(23, 0, 20));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(10, 3.8, -34.5));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(42, 0,  -12));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(18, 0,  -24));
      } else if (sandbox.map == "Lihid") {
        sun = new THREE.Mesh(new THREE.CircleGeometry(10), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/sun.png"), transparent: true }));
        scene.background = new THREE.Color(0x88ccee);
        sun.position.set(0, 50, 0);
        sun.rotateX(1);
        scene.add(sun);
        scene.fog = new THREE.Fog(0xbbba90, 0, 80);
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(20.5, -.2, -16.5));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(10.5, -1.4, -8));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(-2, -1.4, 15));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(10, -1.4, 19));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(14, -1.4, 0));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(27.5, .2, 1.6));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(28, -.4, 7.5));
      } else if (sandbox.map == "Aero") {
        GRAVITY = 25;
        let sphere = new THREE.SphereGeometry(500, 60, 40);
        space = new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/space.png") }));
        space.material.map.generateMipmaps = false;
        space.material.map.minFilter = THREE.LinearMipMapLinearFilter;
        space.material.map.needsUpdate = true;
        scene.background = null;
        space.material.side = THREE.DoubleSide;
        scene.add(space);
        scene.fog = null;
      } else if (sandbox.map == "Complex") {
        let sphere = new THREE.SphereGeometry(500, 60, 40);
        sky = new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/clouds.png") }));
        sky.material.map.generateMipmaps = false;
        sky.material.map.minFilter = THREE.LinearMipMapLinearFilter;
        sky.material.map.needsUpdate = true;
        scene.background = null;
        sky.material.side = THREE.DoubleSide;
        scene.add(sky);
        scene.fog = null;
      }
      document.addEventListener("mousedown", function(event) {
        utils.weapons.data(sandbox.currentWeapon).then(weapon => {
          if (weapon.name == "Assault_Rifle") {
            utils.options.set("RapidFire", true);
          }
          if (weapon.name == "Glock_19") {
            utils.weapons.shoot();
          }
          if (weapon.name == "Sniper_Rifle") {
            utils.weapons.shoot(1, 100);
          }
          if (weapon.name == "Micro_Uzi") {
            utils.weapons.shoot(3, 3);
          }
          if (weapon.name == "Auto_Pistol") {
            utils.options.set("RapidFire", true);
          }
        });
      });
      document.addEventListener("mouseup", function(event) {
        utils.options.set("RapidFire", false);
      });
      let rapidFire = setInterval(function() {
        if (utils.options.get("RapidFire")) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (x.name == "Assault_Rifle") utils.weapons.shoot();
          });
        }
      }, 75);
      let rapidFire1 = setInterval(function() {
        if (utils.options.get("RapidFire")) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (x.name == "Auto_Pistol") utils.weapons.shoot();
          });
        }
      }, 30);
      utils.options.set("CanFire", true);
      utils.options.set("Reloading", false);
      utils.options.set("RunHealth", 100);
      utils.options.set("WeaponLocked", true);
      utils.options.set("Zoomed", false);
      utils.options.set("TouchDevice", window.matchMedia("(pointer: coarse)").matches);
      utils.options.set("TempObjects", []);
      utils.options.set("Bobbing", null);
      utils.options.set("WeaponBoxes", {});
      utils.options.set("TouchingWeapon", null);

      /* Multiplayer setup */
      gametime.make("playerAction");
      gametime.on("playerAction", function(message) {
        let data = message.split(",");
        let user = data[0];
        let action = data[1];
        let metadata = JSON.parse(data.splice(2).join(",").replace(/(\')/gi, "\""));
        let isUser = user == gametime.user.position;
        if (!isUser && action == "walk") {
          sandbox.models["player"].object.position.set(metadata.x, metadata.y - 1, metadata.z);
        }
      });
      function call(action, metadata) {
        return;
        let parsedMetaData = JSON.stringify(metadata).replace(/(\")/gi, "'");
        let parameters = gametime.user.position + "," + action.toString() + "," + parsedMetaData;
        gametime.run("playerAction", [parameters.toString()]);
      }
      let params = { code: "ShiftLeft", key: "Shift" };
      const TouchUI = new UI("touch", function(type, parameters) {
        if (type == "move") {
          if (parameters.positive) {
            if (parameters.where == "forward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" }));
              if (parameters.run) {
                !params.repeat && document.dispatchEvent(new KeyboardEvent("keydown", params));
                params.repeat = true;
              } else {
                params.repeat = false;
                document.dispatchEvent(new KeyboardEvent("keyup", params));
              }
            } else if (parameters.where == "forward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "forward-right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyD", key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
            } else if (parameters.where == "right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyD", key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
            } else if (parameters.where == "backward-right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyS", key: "s" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyD", key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
            } else if (parameters.where == "backward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "backward-left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyS", key: "s" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "forward-left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            }
          } else {
            params.repeat = false;
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "ShiftLeft", key: "Shift" }));
          }
        } else if (type == "jump") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "Space", key: " " }));
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "Space", key: " " }));
          }
        } else if (type == "shoot") {
          if (parameters.positive) {
            utils.options.get("Zoomed") || document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyI", key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyI", key: "i" }));
            setTimeout(() => {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyF", key: "f" }));
            }, 100);
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyF", key: "f" }));
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyI", key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyI", key: "i" }));
            keyStates["KeyF"] = false;
            keyStates["KeyI"] = false;
          }
        } else if (type == "fire") {
          if (parameters.positive) {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyF", key: "f" }));
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyF", key: "f" }));
            keyStates["KeyF"] = false;
          }
        } else if (type == "zoom") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyI", key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyI", key: "i" }));
          }
        } else if (type == "reload") {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            let weapon = x;
            let cweapon = sandbox.weapons[sandbox.weapons.indexOf(weapon)];
            if (cweapon.rounds < cweapon.maxRounds) {
              utils.weapons.reload();
            }
          });
        } else if (type == "throw") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyM", key: "m" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyM", key: "m" }));
          }
        } else if (type == "melee") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyB", key: "b" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyB", key: "b" }));
          }
        } else if (type == "swap") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyY", key: "y" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyY", key: "y" }));
          }
        }
      });
      if (utils.options.get("TouchDevice")) document.body.appendChild(TouchUI.domElement);
    </script>
  </body>
</html>