<!DOCTYPE html>
<html lang="en">
  <head>
    <title>FPS3 Prototype</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      @font-face {
        font-family: "Roboto";
        src: url(fonts/Roboto.ttf);
      }
      html, body {
        margin: 0;
        overflow: hidden !important;
        touch-action: none !important;
        user-select: none !important;
        -webkit-user-select: none !important;
        -khtml-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        -webkit-touch-callout: none !important;
      }
      .ui .crosshair {
        position: fixed;
        width: 40px;
        height: 40px;
        margin: 0;
        left: 50%;
        top: 50%;
        margin-left: -20px;
        margin-top: -20px;
      }
      .ui-centering, .center {
        margin: 0;
        padding: 0;
      }
      .ui img, .ui .drop-shadow {
        filter: drop-shadow(3px 3px 3px rgba(0, 0, 0, .3));
      }
      .ui .container {
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .font-size-large {
        font-size: 30px;
      }
      * {
        font-family: "Roboto", Arial;
        color: #fff;
        text-shadow: 1px 2px 3px rgba(0, 0, 0, 0.3);
      }
      .ui .primary-holder {
        position: absolute;
        left: 2%;
      }
      .ui .secondary-holder {
        position: absolute;
        left: 2%;
        bottom: 80px;
      }
      .ui .third-holder {
        position: absolute;
        left: 2%;
        bottom: 40px;
      }
      .ui .health-display {
        background: rgba(0, 0, 0, .25);
        width: 130px;
        height: 15px;
        padding: 0;
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .ui .health, .ui .run-health {
        position: relative;
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
        background: #fff;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.24);
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .ui .health span, .ui .run-health span {
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      img {
        pointer-events: none !important;
      }
      .ui .info-marker {
        position: absolute;
        width: 100%;
        left: 0;
        right: 0;
        bottom: 20px;
        visibility: hidden;
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
        z-index: 999999999;
      }
      .ui .info-marker > span {
        position: relative;
        text-align: center;
        backdrop-filter: blur(5px);
        border-radius: 5px;
        padding: 6px;
        color: #fff;
        border: .1px solid #fff;
      }
      .ui img.scope {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: cover;
        pointer-events: none;
        visibility: hidden;
        margin: 0;
      }
      .loading {
        position: fixed;
        width: 100%;
        height: 100%;
        z-index: 99999999999999999999999999999;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        background-image: url(images/assets/maps/Cargo.png);
        background-color: #000;
        background-size: cover;
        transition: opacity 2s;
        pointer-events: none;
      }
      #loading-fade {
        position: absolute;
        width: 100% !important;
        height: 100% !important;
        object-fit: fill !important;
        z-index: 9999999999999999999999999999;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
      }
      .loading-bar {
        position: fixed;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.24);
        background: #fff;
        height: 10px;
        left: 0;
        top: 0;
        transition: width 2s;
      }
      .banner {
        position: absolute;
        background: #000;
        width: 100% !important;
        height: 100% !important;
        z-index: 99999999999999999999999;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        transition: opacity .4s;
        pointer-events: none;
      }
      .users {
        width: 30%;
        height: 50%;
        margin: 0;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -30%);
      }
      .users .column {
        width: 100%;
        height: 60px;
        background: #fff;
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
        color: #333;
        margin-bottom: 5px;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      @keyframes spin-reverse {
        0% {
          transform: rotate(360deg);
        }
        100% {
          transform: rotate(0deg);
        }
      }
      .spin {
        border: 2px solid #f3f3f3;
        display: inline-block;
        border-top: 2px solid #333;
        border-radius: 50%;
        width: 10px;
        height: 10px;
        margin-left: 15px;
        animation: spin 2s linear infinite;
      }
      .spin-reverse {
        animation: spin-reverse 2s linear infinite;
      }
      .spin.spin-large {
        width: 40px;
        height: 40px;
      }
      .center {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .shadow {
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.24);
      }
      .before-ui {
        position: absolute;
        visibility: hidden;
        z-index: 9999999999999;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        padding: 0;
        margin: 0;
      }
      .center-origin {
        display: inline-flex;
        text-align: center;
        align-items: center;
        justify-content: center;
      }
      .description {
        width: 200px;
        height: 200px;
        white-space: normal;
        border: 1px solid #fff;
        border-radius: 4px;
        backdrop-filter: blur(3px);
        text-align: center;
        padding: 0 10px;
      }
      .description-header {
        background: #fff;
        color: #333;
        position: relative;
        width: 100%;
        padding: 8px 0;
      }
      .description-text {
        margin-top: 35px;
      }
      [id^="NotiflixNotify-"] {
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.24);
        background: transparent !important;
        backdrop-filter: blur(5px);
        border-bottom: .5px solid #fff;
      }
      #NotiflixNotifyWrap {
        z-index: 99999999999999999 !important;
      }
      #NotiflixNotifyWrap * {
        color: #fff !important;
      }
      .swal-modal {
        background: transparent;
      }
      [class^="swal-"] {
        color: #eee;
        white-space: nowrap;
      }
      .swal-title {
        font-size: 40px;
        font-weight: 600;
      }
      .swal-text {
        font-size: 20px;
      }
      .swal-overlay {
        backdrop-filter: blur(3px);
      }
      .leaderboard {
        position: absolute;
        display: inline-block;
        text-align: center;
        align-items: center;
        justify-content: center;
        right: 20px;
        top: 20px;
        background: #fff;
        padding: 5px;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1), 0 1px 4px rgba(0, 0, 0, 0.24);
        color: #333 !important;
        width: 170px;
        height: 90px;
        transition: border 2s ease-in-out;
        border: 4px solid transparent;
        box-sizing: border-box;
      }
      .leaderboard * {
        color: #333 !important;
      }
    </style>
	  <script src="https://cdn.jsdelivr.net/gh/Parking-Master/Gametime.js-2.0@latest/gametime.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Parking-Master/Gametime.js@latest/js/username-generator.min.js"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <script src="js/user/user.js"></script>
  </head>
  <body>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="js/FontLoader.min.js"></script>
    <script src="js/GLTFLoader.min.js"></script>
    <script src="js/TextGeometry.min.js"></script>
    <script src="js/fflate.min.js"></script>
    <script src="js/Capsule.min.js"></script>
    <script src="js/Octree.min.js"></script>
    <script src="https://mrgoonie.github.io/three.confetti.explosion.js/js/helper.js"></script>
    <script src="js/PointerLockControls.min.js"></script>
    <script src="js/GamepadControls.min.js"></script>
    <script src="js/TouchControls.min.js"></script>
    <script src="js/UI.js"></script>
    <script src="js/ExplosionConfetti.min.js"></script>
    <script src="https://unpkg.com/@seregpie/three.text-texture"></script>
    <script src="https://unpkg.com/@seregpie/three.text-sprite"></script>
    <script src="https://cdn.jsdelivr.net/gh/notiflix/Notiflix@latest/dist/notiflix-aio-3.2.5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/alvaromontoro/gamecontroller.js@latest/dist/gamecontroller.min.js"></script>
    <audio src="sounds/walking.mp3" id="walkingSound" loop></audio>
    <div class="banner">
      <p style="text-align: center; margin-top: 10%; font-size: 2em; font-weight: bold; font-family: Arial, Helvetica, sans-serif !important">[FFA Slayer] - 10 points</span></p>
      <div class="users"></div>
    </div>
    <div class="loading">
      <img id="loading-fade" src="images/html/vignette.png">
      <div class="center"><h1 class="map shadow" style="text-align: center; font-size: 5em; z-index: 99999999999999999; background: rgba(255, 255, 255, .1); backdrop-filter: blur(5px); padding: 10px; border-radius: 5px; border-bottom: .5px solid #fff">LOADING...</h1></div>
      <div class="loading-bar" style="width: 1%"></div>
      <p style="position: absolute; left: 20px; top: 25px"><span class="loading-progress">0</span> %</p>
    </div>
    <div class="before-ui">
      <div class="spin spin-large center-origin" style="position: absolute; left: 20px; top: 20px">
        <p class="spin-reverse counter" style="display: inline-block">10</p>
      </div>
      <div class="description" style="position: absolute; right: 20px; top: 20px">
        <div class="description-header">Slayer</div>
        <div class="description-text">Eliminate enemies using default or power weapons to earn points. First to the score limit wins.</div>
      </div>
    </div>
    <div class="ui">
      <div class="leaderboard">
        <p class="player1"><span class="score">0</span> - <b class="username"></b></p>
        <p class="player2"><span class="score">0</span> - <b class="username"></b></p>
      </div>
      <img class="hit" src="images/other/hit.png" style="transition: opacity .2s; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: 0; padding: 0; opacity: 0;">
      <img class="vignette" src="images/other/blurred_border.png" style="transition: opacity .15s; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; bottom: 0; right: 0; margin: 0; padding: 0;">
      <div class="ui-centering center">
        <img src="images/icons/ui/crosshair.png" class="crosshair drop-shadow">
      </div>
      <div class="ui-holder primary-holder holder">
        <div class="container">
          <p class="placeholder font-size-large current-grenades">0</p><img src="images/icons/ui/grenade.png" style="width: 50px"><p class="placeholder font-size-large">|</p>&ThickSpace;&ThickSpace;<p class="placeholder font-size-large current-ammo">0</p><img src="images/icons/ui/bullet.png" style="width: 50px">
        </div>
      </div>
      <div class="ui-holder secondary-holder holder">
        <div class="health-display">
          <div class="health"><span style="color: #333; display: inline-block; font-size: 12px; white-space: nowrap; display: inline-flex; text-align: center; align-items: center; justify-content: center"><img src="images/icons/heart.png" style="width: 15px"><span class="health-text" style="color: #333">100</span> %</span></div>
        </div>
      </div>
      <div class="ui-holder third-holder holder">
        <div class="health-display">
          <div class="run-health"><span style="color: #333; display: inline-block; font-size: 12px; white-space: nowrap; display: inline-flex; text-align: center; align-items: center; justify-content: center"><img src="images/icons/fast_forward.png" style="width: 20px"><span class="health-text" style="color: #333">100</span> %</span></div>
        </div>
      </div>
      <div class="info-marker"><span></span></div>
      <img class="scope">
    </div>
    <script>
    Notiflix.Notify.init({
      position: "right-bottom",
      timeout: 2000,
      info: {
        width: "300px",
        background: "transparent",
        textColor: "#fff",
        notiflixIconColor: "#fff"
      }
    });
    
    function load(url, callback) {
      if (Object.keys(utils.cache.models).indexOf(url) > -1) return callback(utils.cache.models[url]);
      new THREE.GLTFLoader().load(url, function(model) {
        utils.cache.models[url] = model;
        callback(model);
      });
    }

	  // Game asset variables
	  otherPlayer = new THREE.Mesh();
	  gunHolder = new THREE.Group();
    gunHolder.rotation.set(1.5, .5, 2.9);
    gunHolder.position.set(2.4475877079089363, 22.013294147805205, 1.5569827148359332);
    gunHolder.rotateZ(.4);
    gunHolder.rotateX(-.1);
	  space = new THREE.Mesh();
	  sun = new THREE.Mesh();
    
    let v3 = THREE.Vector3;
    THREE.Vector3 = function(x, y, z, rotation = null) {
      let v = new v3(x, y, z);
      v.rotation = rotation;
      return v;
    }
    Array.prototype.count = function() {
      let counter = 0;
      for (occurence of this) {
        if (occurence == arguments[0]) {
          counter++;
        }
      }
      return counter;
    }
    function confetti(obj) {
      let confetti = new ExplosionConfetti({
        rate: 4,
        amount: 10,
        radius: 100,
        areaWidth: 5,
        areaHeight: 0,
        fallingHeight: 1,
        fallingSpeed: 1,
        colors: [0x999999, 0xaaaaaa, 0xcfcfcf]
      });
      confetti.object.position.copy(obj.position);
      scene.add(confetti.object);
      confetti.object.scale.set(.02, .02, .02);
      let h = setInterval(() => (confetti.object.traverse((x) => (x.position.y = 0, x.material && (x.material.opacity += -.02))), confetti.update()));
      setTimeout((() => (confetti.dispose(), clearInterval(h))), 1000);
    }

	  THREE.Sound = function Sound(source = null, object = new THREE.Object3D, callback = function(sound) {}, preserve3d = true, volume = 5, loop) {
      if (!preserve3d) {
        let sound = document.createElement("audio");
        sound.src = source;
        sound.play();
        loop && (sound.loop = loop);
        return;
      }
	    typeof camera.getObjectByProperty("type", "AudioListener") == "undefined" && camera.add(new THREE.AudioListener());
		  let sound = new THREE.PositionalAudio(camera.getObjectByProperty("type", "AudioListener"));
		  new THREE.AudioLoader().load(source, (buffer) => {
		    sound.setBuffer(buffer);
		    sound.setRefDistance(5);
		    sound.setVolume(volume);
		    callback(sound);
		    sound.play();
		  });
		  object.add(sound);
	  }
	  utils = {
      cache: {
        options: {},
        models: {}
      },
      options: {
        set: function(key, value) {
          utils.cache.options[key] = value;
        },
        get: function(key) {
          return utils.cache.options[key];
        },
        defineWeapon: function(options = {}) {
          sandbox.weapons.push(options);
        }
      },
      player: {
        weapon: {
          set: function(key) {
            sandbox.weapons.forEach(x => {
              if (x.name == key) {
                let gun = x.object.getObjectByName("handR_025").children[x.object.getObjectByName("handR_025").children.length - 1].clone();
                gun.scale.set(10, 10, 10);
                gun.rotation.set(0, 0, -Math.PI / 2);
                gun.translateX(-12);
                gun.translateY(2);
                sandbox.models["player"].object.getObjectByName("mixamorigRightHand").add(gun);
              }
            });
          }
        }
      },
      camera: {
        shake: function(intensity, rate = 100) {
          let t = 0;
          let h = setInterval(() => {
            if (t >= intensity / 20) {
              return (() => {
                let t = 0;
                let h = setInterval(() => {
                  if (t >= intensity / 20) {
                    return clearInterval(h);
                  }
                  camera.rotateX(-.005);
                  t += .005;
                });
              })(), clearInterval(h);
            }
            camera.rotateX(.005);
            t += .005;
          }, 100 - rate);
        },
        zoomIn: function(o) {
          if (utils.options.get("Zoomed")) return;
          utils.options.set("Zoomed", true);
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (x.name == "Sniper_Rifle") {
              document.querySelector(".crosshair").style.visibility = "hidden";
              weaponScene.remove(sandbox.currentWeapon);
              const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
              let t = 0;
              let transition = setInterval(() => {
                t >= 65  ? clearInterval(transition) : (camera.fov = e - t, weaponCamera.fov = e - t);
                t += 2;
                camera.updateProjectionMatrix();
                weaponCamera.updateProjectionMatrix();
              });
              document.querySelector(".ui").querySelector(".scope").src = "images/icons/ui/scope.png";
              document.querySelector(".ui").querySelector(".scope").style.visibility = "visible";
              PointerControls.pointerSpeed = PointerControls.pointerSpeed / 2;
              TouchControls.speed = TouchControls.speed / 2;
              document.querySelector(".vignette").style.opacity = 0;
              return;
            }
            const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
            let t = 0;
            let transition = setInterval(() => {
              t >= 26 ? clearInterval(transition) : (camera.fov = e - t, weaponCamera.fov = e - t);
              t += 2;
              camera.updateProjectionMatrix();
              weaponCamera.updateProjectionMatrix();
            });
            if (x.name == "Grenade_Launcher") {
              document.querySelector(".ui").querySelector(".scope").src = "images/icons/ui/scope1.png";
              document.querySelector(".ui").querySelector(".scope").style.visibility = "visible";
              weaponScene.remove(sandbox.currentWeapon);
            }
            document.querySelector(".crosshair").src = "images/icons/ui/crosshair_zoomed.png";
            PointerControls.pointerSpeed = PointerControls.pointerSpeed / 2;
            TouchControls.speed = TouchControls.speed / 2;
            document.querySelector(".vignette").style.opacity = 0;
          });
        },
        zoomOut: function(o) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (!utils.options.get("Zoomed")) return;
            utils.options.set("Zoomed", false);
            if (x.name == "Sniper_Rifle" || x.name == "Grenade_Launcher") weaponScene.add(sandbox.currentWeapon);
            document.querySelector(".crosshair").style.visibility = "visible";
            const e = Math.floor(2 * Math.atan(camera.getFilmHeight() / 2 / camera.getFocalLength()) * 180 / Math.PI);
            let t = 0;
            let transition = setInterval(() => {
              t >= (x.name == "Sniper_Rifle" ? 65 : 26) ? clearInterval(transition) : (camera.fov = e + t, weaponCamera.fov = e + t);
              t += 2;
              camera.updateProjectionMatrix();
              weaponCamera.updateProjectionMatrix();
            });
            document.querySelector(".crosshair").src = "images/icons/ui/crosshair.png";
            PointerControls.pointerSpeed = PointerControls.pointerSpeed * 2;
            TouchControls.speed = TouchControls.speed * 2;
            document.querySelector(".vignette").style.opacity = 1;
            document.querySelector(".ui").querySelector(".scope").src = "";
            document.querySelector(".ui").querySelector(".scope").style.visibility = "hidden";
          });
        }
      },
      ui: {
        infoMarker: {
          show: function(text, callback) {
            document.querySelector(".ui").querySelector(".info-marker").querySelector("span").textContent = text;
            document.querySelector(".ui").querySelector(".info-marker").style.visibility = "visible";
            if (callback) document.querySelector(".ui").querySelector(".info-marker").ontouchstart = () => callback();
          },
          hide: function() {
            document.querySelector(".ui").querySelector(".info-marker").querySelector("span").textContent = "";
            document.querySelector(".ui").querySelector(".info-marker").style.visibility = "hidden";
          }
        },
        notify: function(msg, icon) {
          Notiflix.Notify[icon](msg);
        },
        dialog: function(title, text, timeout) {
          swal({
            title: title,
            text: text,
            closeOnClickOutside: false,
            closeOnEsc: false,
            closeOnEnterKey: false,
            closeOnSpaceKey: false,
            button: false
          });
          setTimeout(() => swal.close(), timeout);
        },
        medal: function(name, points) {
          sandbox.medals.push(name.trim());
          let icon = "images/icons/medals/" + name.toLowerCase() + ".png";
          name = name.replace(/_/gi, " ");
          name = (name[0].toUpperCase() + name.toLowerCase().slice(1));
          utils.options.set("ActiveMedals", utils.options.get("ActiveMedals") + 1);
          let medal = document.createElement("div");
          let medals = [];
          document.querySelectorAll(".medal").forEach(x => {
            medals.push(x.textContent.toLowerCase().trim());
          });
          if (medals.indexOf(name.toLowerCase().trim()) > -1) return;
          medal.innerHTML = `
          +${points}&ThickSpace;&ThickSpace;<img src="${icon}" width="30px">&ThickSpace;&ThickSpace;<span class="medal" style="color: #333 !important">${name}</span>
          `;
          medal.style = `
          transition: transform 1s ease-in;
          display: inline-flex;
          position: absolute;
          z-index: 9999999999999999999;
          align-items: center;
          justify-content: center;
          text-align: center;
          color: #333 !important;
          top: ${(150 + ((utils.options.get("ActiveMedals") - 1) * 35))}px;
          left: 200px;
          filter: invert(100%);
          transform: scale(1.5);
          `;
          document.body.appendChild(medal);
          setTimeout(() => medal.style.transform = "", 300);
          setTimeout(() => (document.body.removeChild(medal), utils.options.set("ActiveMedals", utils.options.get("ActiveMedals") - 1)), 3000);
        }
      },
      ammo: {
        create: function(type, position) {
          load("models/assets/ammo/" + type.toLowerCase().trim() + "_ammo.glb", (ammo) => {
            ammo = ammo.scene;
            scene.add(ammo);
            let pos = position.clone();
            pos.y += .05;
            ammo.position.copy(pos);
            ammo.rotateY(Math.random());
            ammoBoxes.push(ammo);
            let run = false;
            let pickup = setInterval(() => {
              if (camera.position.distanceTo(ammo.position) <= 1.5) {
                sandbox.weapons.forEach(x => {
                  if (type.includes(x.ammo.trim())) {
                    if (run) return;
                    run = true;
                    scene.remove(ammo);
                    ammo.position.y = -10000;
                    x.maxClips += 2;
                    x.clips += 2;
                    utils.ui.notify("Picked up " + type.toLowerCase().trim() + " ammo", "info");
                    clearInterval(pickup);
                  }
                });
              }
              if (playerTarget.position.distanceTo(ammo.position) <= 1.5) {
                if (run) return;
                run = true;
                scene.remove(ammo);
                ammo.position.y = -10000;
                clearInterval(pickup);
              }
            });
          });
        }
      },
	    weapons: {
        punch: function(damage = 50) {
          if (utils.options.get("Punching")) return;
          new THREE.Sound("sounds/punch.mp3", sandbox.currentWeapon, () => {}, false);
          utils.camera.zoomOut();
          utils.options.set("Punching", true);
          setTimeout(() => utils.camera.shake(1), 200);
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            setTimeout(() => (utils.options.set("Punching", false), weapon.mixer.clipAction(weapon.animations[11]).stop()), 1500);
            let clip = weapon.mixer.clipAction(weapon.animations[11]);
            clip.loop = THREE.LoopOnce;
            clip.clampWhenFinished = true;
            clip.reset();
            clip.setDuration(.5);
            clip.play();
            setTimeout(() => (clip.timeScale = -1, clip.paused = false), 500);
          });
          if (sandbox.currentWeapon.position.distanceTo(playerTarget.position) <= 1.5) {
            call("hit", {
              damage: damage
            });
          }
        },
        data: function(weapon) {
          return new Promise(function(resolve, reject) {
            sandbox.weapons.forEach(x => x.object == weapon && resolve(x));
          });
        },
        shoot: function(rounds = 1, sound = true, depleteRounds = true, rate = 60) {
          if (!utils.options.get("CanFire")) return;
          let i = 0;
          let weapon = null;
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            weapon = x;
          });
          let shooting = setInterval(() => {
            if (i >= rounds) {
              return clearInterval(shooting);
            }
            i++;
            let damage = 0;
            if (weapon) {
              let cweapon = sandbox.weapons[sandbox.weapons.indexOf(weapon)];
              if (cweapon.rounds - 1 <= cweapon.minRounds) {
                utils.weapons.reload();
              }
              if (cweapon.rounds <= cweapon.minRounds) {
                return;
              }
              call("shoot", {
                weapon: cweapon.name
              });
              depleteRounds && cweapon.rounds--;
              depleteRounds && cweapon.roundsUsed++;
              let ammo = cweapon.ammo;
              if (ammo == "heavy") {
                damage = 5;
              }
              if (ammo == "sniper") {
                damage = 100;
              }
              if (ammo == "light") {
                damage = 3;
              }
              if (ammo == "shotgun") {
                damage = 20;
              }
              if (ammo == "rocket") {
                damage = 200;
                if (cweapon.name == "Rocket_Pistol") {
                  const deltaTime = clock.getDelta();
                  utils.camera.zoomOut();
                  utils.weapons.data(sandbox.currentWeapon).then(weapon => {
                    let clip = weapon.mixer.clipAction(weapon.animations[2]);
                    clip.loop = THREE.LoopOnce;
                    clip.reset();
                    clip.play();
                  });
                  setTimeout(() => utils.camera.shake(1), 50);
                  const rocket = {
                    mesh: new THREE.Mesh(new THREE.CylinderGeometry(.1, .1, 1), new THREE.MeshBasicMaterial({ color: 0xffffff })),
                    collider: new THREE.Sphere(new THREE.Vector3(0, - 100, 0), SPHERE_RADIUS * 2),
                    velocity: new THREE.Vector3()
                  };
                  camera.getWorldDirection(playerDirection);
                  rocket.collider.center.copy(playerCollider.end).addScaledVector(playerDirection, playerCollider.radius * 1.5);
                  const impulse = 15 + 30 * (1 - Math.exp((mouseTime - performance.now()) * 0.001));
                  rocket.velocity.copy(playerDirection).multiplyScalar(impulse);
                  rocket.velocity.addScaledVector(playerVelocity, 2);
                  weaponScene.add(rocket.mesh);
                  rocket.mesh.rotation.copy(camera.rotation);
                  rocket.mesh.rotateX(Math.PI / 2);
                  let collided = setInterval(() => {
                    if (worldOctree.sphereIntersect(rocket.collider)) {
                      let mark = new THREE.Mesh(new THREE.CircleGeometry(1), new THREE.MeshBasicMaterial({ transparent: true, map: new THREE.TextureLoader().load("images/textures/mark.png") }));
                      scene.add(mark);
                      mark.position.copy(rocket.mesh.position);
                      mark.rotateX(-Math.PI / 2);
                      mark.position.y += -.15;
                      mark.scale.set(4, 4, 4);
                      utils.explosion(rocket.mesh);
                      weaponScene.remove(rocket.mesh);
                      new THREE.Sound("sounds/explosion.mp3", rocket.mesh, () => {}, true, 20);
                      clearInterval(collided);
                    }
                    rocket.collider.center.addScaledVector(rocket.velocity, .1);
                    const damping = Math.exp(- 1.5 * (deltaTime - .01)) - 1.003;
                    rocket.velocity.addScaledVector(rocket.velocity, damping);
                    rocket.mesh.position.copy(rocket.collider.center);
                  });
                  sound && new THREE.Sound("sounds/guns/Rocket_Pistol/fire.mp3", sandbox.currentWeapon, () => {}, false);
                  setTimeout(() => (clearInterval(collided), weaponScene.remove(rocket.mesh)), 10000);
                  return;
                }
              }
              if (ammo == "grenade") {
                sandbox.grenades.current++;
                utils.weapons.grenades.throw(false);
              }
            }
            let randomX = Math.random() / 20;
            let randomY = Math.random() / 20;
            let shakyWeapon = sandbox.currentWeapon.clone();
            let shakyCamera = camera.clone();
            shakyCamera.rotateY(randomY);
            shakyCamera.rotateX(randomX);
            shakyWeapon.rotateZ(randomY);
            shakyWeapon.rotateX(randomX);
            sandbox.weapons.forEach(x => x.object == sandbox.currentWeapon && (x.mixer.clipAction(x.animations[2]).reset(), x.mixer.clipAction(x.animations[2]).loop = THREE.LoopOnce, x.mixer.clipAction(x.animations[2]).reset(), x.mixer.clipAction(x.animations[2]).play(), x.mixer.clipAction(x.animations[2]).timeScale = 5, x.mixer.clipAction(x.animations[2]).fadeIn()));
            utils.camera.shake(.2);
            let guide = new THREE.Group();
            guide.add(new THREE.Mesh(new THREE.CylinderGeometry(.005, .005, .05), new THREE.MeshBasicMaterial({ color: 0xffffff })));
            guide.children[0].rotateX(Math.PI / 2);
            guide.children[0].translateY(.5);
            scene.add(guide);
            let e = new THREE.Mesh(new THREE.CircleGeometry(1));
            guide.position.copy(camera.position);
            e.position.copy(camera.position);
            e.rotation.copy(utils.options.get("Zoomed") ? camera.rotation : shakyCamera.rotation);
            guide.rotation.copy(utils.options.get("Zoomed") ? camera.rotation : shakyCamera.rotation);
            e.updateMatrix();
            let hole = new THREE.SpotLight(100, 0x999999, 10000);
            let objects = utils.options.get("TempObjects");
            objects.push(hole);
            if (objects.length > 10) (scene.remove(objects[0]), objects.shift());
            utils.options.set("TempObjects", objects);
            setTimeout(() => (scene.remove(hole), delete e, delete hole), 10000), scene.add(hole), hole.color = 0x999999, hole.penumbra = .1, hole.angle = .003, hole.position.copy(e.position), hole.target = e, hole.rotation.copy(e.rotation), hole.translateZ(1), e.material = new THREE.MeshPhongMaterial({ opacity: 0, side: THREE.DoubleSide });
            let h = setInterval(() => {
              map.traverse((x) => {
                if (x.isObject3D && ((!x.name.includes("scene") && !x.name.includes("Scene")) && collision(e, x))) {
                  return setTimeout(() => (scene.remove(hole), delete e, delete hole), 10000), scene.add(hole), hole.color = 0x999999, hole.penumbra = .1, hole.angle = .003, hole.position.copy(e.position), hole.target = e, hole.rotation.copy(e.rotation), hole.translateZ(1), e.material = new THREE.MeshPhongMaterial({ opacity: 0, side: THREE.DoubleSide }), clearInterval(h);
                }
                e.translateZ(-.02);
              });
            }, 10);
            let guideTranslate = setInterval(() => {
              ammoBoxes.forEach(x => collision(guide, x) && (ammoBoxes.splice(ammoBoxes.indexOf(x), 1), utils.explosion(x), scene.remove(x), load("models/assets/ammo/burnt_ammo.glb", (l) => (l = l.scene, l.position.copy(x.position), l.rotation.copy(x.rotation), x = l, scene.add(x)))));
              if (collision(guide, playerTarget)) {
                call("hit", {
                  damage: !utils.options.get("Zoomed") ? damage / 2 : damage
                });
                sandbox.models["player"].object.getObjectByName("mixamorigNeck").rotateX(-.2);
                setTimeout(() => sandbox.models["player"].object.getObjectByName("mixamorigNeck").rotateX(.2), 50);
              }
              guide.translateZ(-.5);
            });
            setTimeout(() => clearInterval(guideTranslate), 10000);
            if (weapon.name == "Sniper_Rifle" && utils.options.get("Zoomed")) {
              utils.camera.shake(1);
            }
            let flash = sandbox.models["flash"].object;
            sound && new THREE.Sound("sounds/guns/" + weapon.name + "/fire.mp3", sandbox.currentWeapon, () => {}, false);
            flash.children[0].material.opacity = 1;
            flash.scale.set(.1, .1, .1);
            flash.position.copy(sandbox.currentWeapon.position);
            flash.rotation.copy(sandbox.currentWeapon.rotation);
            flash.translateY(.11);
            flash.rotateY(Math.PI);
            flash.translateX(.08);
            flash.translateZ(-.3);
            let sticky = setInterval(() => {
              flash.position.copy(sandbox.currentWeapon.position);
              flash.rotation.copy(sandbox.currentWeapon.rotation);
              flash.translateY(.11);
              flash.rotateY(Math.PI);
              flash.translateX(.08);
              flash.translateZ(-.3);
            });
            let shell = sandbox.models["shell"].object;
            shell.position.copy(sandbox.currentWeapon.position);
            shell.rotation.copy(sandbox.currentWeapon.rotation);
            shell.scale.copy(sandbox.currentWeapon.scale);
            weaponScene.add(shell);
            let effect = setInterval(() => {
              shell.translateX(-.07);
              shell.position.y += -.03;
            });
            setTimeout(() => (weaponScene.remove(shell), clearInterval(effect)), 1000);
            let light = new THREE.PointLight(0xf99c00, 1, 4, 3);
            light.position.copy(flash.position);
            light.rotation.copy(flash.rotation);
            weaponScene.add(flash);
            scene.add(light);
            let lightClone = light.clone();
            weaponScene.add(lightClone);
            document.querySelector(".crosshair").style.transition = "transform .05s ease-out", document.querySelector(".crosshair").style.transform = "scale(1.15)", setTimeout(() => document.querySelector(".crosshair").style.transform = "", 100);
            setTimeout(() => (weaponScene.remove(flash), weaponScene.remove(lightClone), scene.remove(light), clearInterval(sticky)), 25);
          }, rate);
        },
        pickup: function(weapon) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            let e = sandbox.models[x.name].object.clone();
            scene.add(e);
            e.scale.set(.1, .1, .1);
            e.position.set(camera.position.x, camera.position.y - 1, camera.position.z);
            let boxes = utils.options.get("WeaponBoxes");
            let clone = boxes;
            let weaponArray = [];
            Object.keys(clone).forEach(x => {
              x = x.replace(/\-[0-9]/gi, "");
              weaponArray.push(x);
            });
            weaponArray.push(x.name);
            let id = weaponArray.count(x.name);
            let newWeapon = x.name + "-" + id;
            boxes[newWeapon] = e;
            utils.options.set("WeaponBoxes", boxes);
            let h = setInterval(() => {
              if (camera.position.distanceTo(e.position) <= 2) {
                utils.options.set("TouchingWeapon", e);
                if (sandbox.loadout.indexOf(x.name) > -1) {
                  let position = sandbox.currentWeapon == sandbox.primaryWeapon ? 0 : 1;
                  sandbox.weapons.forEach(i => {
                    if (i.name == x.name) {
                      i.maxClips += x.clips;
                      i.clips += x.clips;
                      let boxes = utils.options.get("WeaponBoxes");
                      boxes[newWeapon].position.y = -10000;
                      scene.remove(boxes[newWeapon]);
                      delete boxes[newWeapon];
                      utils.options.set("WeaponBoxes", boxes);
                      clearInterval(h);
                      utils.ui.infoMarker.hide();
                    }
                  });
                }
                if (utils.options.get("TouchDevice")) {
                  utils.ui.infoMarker.show("Hold to pick up " + x.name.replace(/\_/gi, " "), () => {
                    document.dispatchEvent(new KeyboardEvent("keydown", { key: "t", code: "KeyT" }));
                    document.dispatchEvent(new KeyboardEvent("keyup", { key: "t", code: "KeyT" }));
                  });
                } else {
                  utils.ui.infoMarker.show("Hold [T] to pick up " + x.name.replace(/\_/gi, " "));
                }
              } else {
                utils.options.get("TouchingWeapon") == e && utils.options.set("TouchingWeapon", null);
                !utils.options.get("TouchingWeapon") && utils.ui.infoMarker.hide();
              }
            });
            document.addEventListener("keydown", function(event) {
              if (event.key == "t" && camera.position.distanceTo(e.position) <= 2) {
                utils.weapons.pickup(newWeapon);
                let boxes = utils.options.get("WeaponBoxes");
                pointers[newWeapon].position.y = -10000;
                scene.remove(pointers[newWeapon]);
                delete pointers[newWeapon];
                delete boxes[newWeapon];
                utils.options.set("WeaponBoxes", boxes);
                clearInterval(h);
                utils.ui.infoMarker.hide();
              }
            });
          });
          let weaponBox = utils.options.get("WeaponBoxes")[weapon];
          scene.remove(weaponBox);
          weaponBox.position.y = -10000;
          typeof weaponBox.getObjectByName("BoxFBX") != undefined && call("remove", {
            id: weapon
          });
          let newWeapon = null;
          sandbox.weapons.forEach(x => {
            if (weapon.includes(x.name)) {
              newWeapon = x;
              weaponScene.remove(sandbox.currentWeapon);
              let position = sandbox.currentWeapon == sandbox.primaryWeapon ? 0 : 1;
              sandbox.loadout[position] = newWeapon.name;
              position == 0 ? sandbox.primaryWeapon = newWeapon.object : sandbox.secondaryWeapon = newWeapon.object;
              utils.weapons.switch();
              sandbox.currentWeapon != x.object && utils.weapons.switch();
              call("pickup", {
                loadout: sandbox.loadout
              });
            }
          });
        },
        create: function(weapon = "", pos = new THREE.Vector3(), useAmmo = true) {
          let box = new THREE.Object3D();
          load("models/assets/pointer.glb", function(pointer) {
            pointer = pointer.scene;
            let boxName = null;
            let newWeapon;
            load("models/assets/weapon_box.glb", function(gltf) {
              box = gltf.scene;
              box.scale.set(.01, .01, .01);
              box.position.set(pos.x, pos.y, pos.z);
              scene.add(box);
              let boxes = utils.options.get("WeaponBoxes");
              let clone = boxes;
              let weaponArray = [];
              Object.keys(clone).forEach(x => {
                x = x.replace(/\-[0-9]/gi, "");
                weaponArray.push(x);
              });
              weaponArray.push(weapon);
              let id = weaponArray.count(weapon);
              newWeapon = weapon + "-" + id;
              boxName = newWeapon;
              boxes[newWeapon] = box;
              pointers[newWeapon] = pointer;
              sandbox.weapons.forEach(x => {
                if (x.name != weapon || !useAmmo) return;
                utils.ammo.create(x.ammo, new THREE.Vector3(pos.x - .5, pos.y, pos.z));
                utils.ammo.create(x.ammo, new THREE.Vector3(pos.x - .5, pos.y, pos.z - .5));
              });
              pointer.position.copy(box.position);
              weaponScene.add(pointer);
              utils.options.set("WeaponBoxes", boxes);
            });
            let h = setInterval(() => {
              if (camera.position.distanceTo(box.position) <= 2) {
                utils.options.set("TouchingWeapon", box);
                if (sandbox.loadout.indexOf(weapon) > -1) {
                  let position = sandbox.loadout.indexOf(weapon);
                  utils.weapons.data(position == 0 ? sandbox.primaryWeapon : sandbox.secondaryWeapon).then(x => {
                    sandbox.weapons.forEach(i => {
                      if (i.name == weapon) {
                        i.maxClips += x.clips;
                        i.clips += x.clips;
                        let boxes = utils.options.get("WeaponBoxes");
                        boxes[newWeapon].position.y = -10000;
                        pointers[newWeapon].position.y = -10000;
                        scene.remove(boxes[newWeapon]);
                        scene.remove(pointers[newWeapon]);
                        delete pointers[newWeapon];
                        delete boxes[newWeapon];
                        utils.options.set("WeaponBoxes", boxes);
                        clearInterval(h);
                        utils.ui.infoMarker.hide();
                      }
                    });
                  });
                }
                utils.ui.infoMarker.show("Hold [T] to pick up " + weapon.replace(/\_/gi, " "));
              } else {
                utils.options.get("TouchingWeapon") == box && utils.options.set("TouchingWeapon", null);
                !utils.options.get("TouchingWeapon") && utils.ui.infoMarker.hide();
              }
            });
            document.addEventListener("keydown", function(event) {
              if (event.key == "t" && camera.position.distanceTo(box.position) <= 2) {
                utils.weapons.pickup(boxName);
                let boxes = utils.options.get("WeaponBoxes");
                pointers[boxName].position.y = -1000;
                scene.remove(pointers[boxName]);
                delete boxes[boxName];
                delete pointers[boxName];
                utils.options.set("WeaponBoxes", boxes);
                clearInterval(h);
                utils.ui.infoMarker.hide();
              }
            });
          });
        },
		    switch: function() {
          call("switch", {});
          utils.camera.zoomOut();
		    	let newWeapon;
		    	let oldWeapon = sandbox.currentWeapon;
		      if (sandbox.currentWeapon == sandbox.primaryWeapon)
		  	    newWeapon = sandbox.secondaryWeapon;
		  	  else newWeapon = sandbox.primaryWeapon;
		  	  weaponScene.remove(oldWeapon);
		  	  sandbox.currentWeapon = newWeapon;
		  	  sandbox.weapons.forEach(x => {
		  	    if (!(x.object == sandbox.currentWeapon)) return;
		  	    x.mixer.clipAction(x.animations[0]).reset();
		  	    x.mixer.clipAction(x.animations[0]).loop = THREE.LoopOnce;
		  	    x.mixer.clipAction(x.animations[0]).play();
		  	  });
		  	  weaponScene.add(sandbox.currentWeapon);
		    },
		    reload: function() {
          if (utils.options.get("Reloading")) return;
          utils.camera.zoomOut();
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            if (weapon.clips <= weapon.minClips) return;
            utils.options.set("CanFire", false);
            utils.options.set("Reloading", true);
            keyStates["ShiftLeft"] = false;
            weapon.mixer.clipAction(weapon.animations[1]).stop();
            weapon.mixer.clipAction(weapon.animations[6]).stop();
            weapon.mixer.clipAction(weapon.animations[7]).stop();
            weapon.mixer.clipAction(weapon.animations[9]).stop();
            weapon.roundsUsed += weapon.rounds;
            if (weapon.rounds <= 0) {
              new THREE.Sound("sounds/guns/" + weapon.name + "/full.mp3");
              let index = weapon.reloads.full.useDefaultAnimation ? 4 : 5;
              weapon.mixer.clipAction(weapon.animations[index]).timeScale = 2.5;
              weapon.mixer.clipAction(weapon.animations[index]).loop = THREE.LoopOnce;
              weapon.mixer.clipAction(weapon.animations[index]).reset();
              weapon.mixer.clipAction(weapon.animations[index]).play();
            } else {
              new THREE.Sound("sounds/guns/" + weapon.name + "/easy.mp3");
              weapon.mixer.clipAction(weapon.animations[3]).timeScale = 2.5;
              weapon.mixer.clipAction(weapon.animations[3]).loop = THREE.LoopOnce;
              weapon.mixer.clipAction(weapon.animations[3]).reset();
              weapon.mixer.clipAction(weapon.animations[3]).play();
            }
            setTimeout(() => {
              sandbox.weapons[sandbox.weapons.indexOf(weapon)].rounds = sandbox.weapons[sandbox.weapons.indexOf(weapon)].maxRounds;
              sandbox.weapons[sandbox.weapons.indexOf(weapon)].clips--;
              utils.options.set("CanFire", true);
              utils.options.set("Reloading", false);
              if ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"])) {
                weapon.mixer.clipAction(weapon.animations[6]).play();
              }
            }, weapon.rounds <= 0 ? weapon.reloads.full.time : weapon.reloads.easy.time);
          });
        },
        unlock: function() {
          utils.options.set("WeaponLocked", false);
        },
        lock: function() {
          utils.options.set("WeaponLocked", true);
        },
        grenades: {
          throw: function(animation = true) {
            if (sandbox.grenades.current <= sandbox.grenades.min) {
              return;
            }
            if (utils.options.get("Punching")) return;
            utils.camera.zoomOut();
            utils.weapons.data(sandbox.currentWeapon).then(weapon => {
              if (!animation) return;
              utils.options.set("Punching", true);
              setTimeout(() => (utils.options.set("Punching", false), weapon.mixer.clipAction(weapon.animations[10]).stop()), 500);
              let clip = weapon.mixer.clipAction(weapon.animations[10]);
              let clipFrom = weapon.mixer.clipAction(weapon.animations[1]);
              clip.loop = THREE.LoopOnce;
              clip.reset();
              clip.setDuration(.5);
              clip.play();
              clip.crossFadeFrom(clipFrom);
            });
            sandbox.grenades.current--;
            setTimeout(() => utils.camera.shake(.5), 100);
            const sphere = spheres[sphereIdx];
            camera.getWorldDirection(playerDirection);
            sphere.collider.center.copy(playerCollider.end).addScaledVector(playerDirection, playerCollider.radius * 1.5);
            const impulse = 15 + 30 * (1 - Math.exp((mouseTime - performance.now()) * 0.001));
            sphere.velocity.copy(playerDirection).multiplyScalar(impulse);
            sphere.velocity.addScaledVector(playerVelocity, 2);
            sphereIdx = (sphereIdx + 1) % spheres.length;
            !(scene.children.indexOf(sphere.mesh) > -1) && scene.add(sphere.mesh);
            let collided = setInterval(() => {
              if (worldOctree.sphereIntersect(sphere.collider)) {
                setTimeout(() => {
                  let mark = new THREE.Mesh(new THREE.CircleGeometry(1), new THREE.MeshBasicMaterial({ transparent: true, map: new THREE.TextureLoader().load("images/textures/mark.png") }));
                  scene.add(mark);
                  mark.position.copy(sphere.mesh.position);
                  mark.rotateX(-Math.PI / 2);
                  mark.position.y += -.15;
                  mark.scale.set(4, 4, 4);
                  utils.explosion(sphere.mesh);
                  scene.remove(sphere.mesh);
                  new THREE.Sound("sounds/explosion.mp3", sphere.mesh, () => {}, true, 20);
                  sphere.hits = 0;
                }, 1000);
                clearInterval(collided);
              }
            });
          }
        }
		  },
      explosion: function(obj, capture = true) {
        let explosion = sandbox.models["explosion"];
        let mixer = explosion.mixer.clipAction(explosion.animations[0]);
        mixer.reset();
        mixer.loop = THREE.LoopOnce;
        mixer.clampWhenFinished = true;
        mixer.play();
        let light = new THREE.PointLight(0xbb3905, 1);
        let lightClone = light.clone();
        explosion = explosion.object;
        explosion.traverse(x => {
          if (!x.material) return;
          x.material.transparent = true;
          x.material.opacity = 1;
        });
        scene.add(explosion);
        explosion.position.copy(obj.position);
        explosion.scale.set(.2, .2, .2);
        scene.add(light);
        light.position.copy(obj.position);
        weaponScene.add(lightClone);
        let fadeIn = setInterval(() => {
          if (explosion.scale.x >= 3) {
            clearInterval(fadeIn);
          } else {
            let increment = .05;
            explosion.scale.set(explosion.scale.x + increment, explosion.scale.y + increment, explosion.scale.z + increment);
          }
        });
        let smoke = sandbox.models["smoke"];
        smoke.object.scale.set(5, 5, 5);
        smoke.object.traverse(x => x.frustumCulled = false);
        let smokeClip = smoke.mixer.clipAction(smoke.animations[0]);
        smoke.object.position.copy(explosion.position);
        smokeClip.reset();
        smokeClip.loop = THREE.LoopOnce;
        smokeClip.clampWhenFinished = true;
        smokeClip.play();
        smoke.object.traverse(x => (x.material && (x.material.opacity = 0)));
        scene.add(smoke.object);
        setTimeout(() => {
          let fadeOut = setInterval(() => {
            smoke.object.traverse(x => (x.material && (x.material.transparent = true, x.material.opacity >= .02 || (x.material.opacity += .001))));
            explosion.traverse(x => {
              if (!x.material) return;
              x.material.transparent = true;
              if (x.material.opacity <= 0) {
                scene.remove(light);
                weaponScene.remove(lightClone);
                scene.remove(x);
                clearInterval(fadeOut);
              } else {
                x.material.opacity += -.01;
                light.intensity <= 0 ? light.intensity = 0 : light.intensity += -.01;
                lightClone.intensity <= 0 ? lightClone.intensity = 0 : lightClone.intensity += -.01;
              }
            });
          });
        }, 500);
        (() => {
          document.querySelector(".vignette").style.filter = "invert(" + (100 - camera.position.distanceTo(explosion.position).toFixed(0)) + "%)"
          let t = (100 - camera.position.distanceTo(explosion.position).toFixed(0));
          let h = setInterval(() => {
            if (t <= 0) {
              return document.querySelector(".vignette").style.filter = "", clearInterval(h);
            }
            t--;
            document.querySelector(".vignette").style.filter = "invert(" + t + "%)"
          });
        })();
        setTimeout(() => scene.remove(explosion), 2000);
        setTimeout(() => scene.remove(smoke.object), 15000);
        if (playerTarget.position.distanceTo(explosion.position) <= 4) {
          call("hit", {
            damage: (playerTarget.position.distanceTo(explosion.position) * 200).toFixed(0) - 0
          });
        }
        capture && call("explosion", {
          position: [explosion.position.x, explosion.position.y, explosion.position.z]
        });
      },
      respawn: function(show = true) {
        let spawnPoint = sandbox.mapRespawnPoints[sandbox.map];
        let tempSpawns = [];
        spawnPoint.forEach(x => {
          playerTarget.position.distanceTo(x) <= 10 || tempSpawns.push(x);
        });
        if (!tempSpawns[0]) {
          tempSpawns.push(spawnPoint[Math.floor(Math.random() * spawnPoint.length)]);
        }
        let respawnPoint = tempSpawns[Math.floor(Math.random() * tempSpawns.length)];
        playerCollider.start.set(respawnPoint.x, respawnPoint.y + .35, respawnPoint.z);
        playerCollider.end.set(respawnPoint.x, respawnPoint.y + 1, respawnPoint.z);
        playerCollider.radius = 0.35;
        camera.position.copy(playerCollider.end);
        camera.rotation.set(respawnPoint.rotation.x, respawnPoint.rotation.y, respawnPoint.rotation.z);
        call("respawn", {
          position: [camera.position.x, camera.position.y, camera.position.z, camera.rotation.x, camera.rotation.y, camera.rotation.z]
        });
        if (show) {
          new THREE.Sound("sounds/load.mp3", null, () => {}, false);
          if (sandbox.mode == "Slayer") {
            sandbox.loadout = ["Assault_Rifle", "Glock_19"];
          }
          if (sandbox.mode == "Teams") {
            sandbox.loadout = ["Assault_Rifle", "Glock_19"];
          }
          if (sandbox.mode == "Fiesta") {
            sandbox.loadout = [sandbox.weapons[Math.floor(Math.random() * sandbox.weapons.length)].name, sandbox.weapons[Math.floor(Math.random() * sandbox.weapons.length)].name];
          }
          if (sandbox.mode == "Snipers") {
            sandbox.loadout = ["Sniper_Rifle", "Sniper_Rifle"];
          }
          if (sandbox.mode == "Oddball") {
            sandbox.loadout = ["Assault_Rifle", "Glock_19"];
          }
          if (sandbox.mode == "Fistfight") {
            sandbox.loadout = ["Knife", "Knife"];
          }
          if (sandbox.mode == "Ctf") {
            sandbox.loadout = ["Assault_Rifle", "Glock_19"];
          }
          if (sandbox.mode == "Koth") {
            sandbox.loadout = ["Assault_Rifle", "Glock_19"];
          }
          weaponScene.remove(sandbox.currentWeapon);
          sandbox.weapons.forEach(x => {
            x.rounds = x.maxRounds;
            x.clips = x.maxClips;
            x.roundsUsed = 0;
          });
          sandbox.grenades.current = sandbox.grenades.max;
          sandbox.primaryWeapon = sandbox.weapons[sandbox.weapons.map(x => x.name == sandbox.loadout[0]).indexOf(true)].object;
          sandbox.secondaryWeapon = sandbox.weapons[sandbox.weapons.map(x => x.name == sandbox.loadout[1]).indexOf(true)].object;
          sandbox.currentWeapon = sandbox.primaryWeapon;
          weaponScene.remove(sandbox.currentWeapon);
          document.querySelector(".ui").style.visibility = "visible";
          weaponScene.add(sandbox.currentWeapon);
        }
      }
	  };
      utils.weapons.create.disable = function() {
        utils.weapons.create = () => {};
      }
      let tempName = generateName();
      sandbox = {
        descriptions: {
          "Slayer": "Eliminate the enemy using default or power weapons to earn points. First to the score limit wins.",
          "Teams": "Team up in a 2v2 Slayer match to eliminate the enemy team. First team to the score limit wins.",
          "Fiesta": "Every time you spawn or respawn you will get a random loadout. First to the score limit wins.",
          "Snipers": "Snipers only match with no map weapons or equipment. First to the score limit wins.",
          "Oddball": "Hold the ball to earn points, and stay away from enemies!",
          "Fistfight": "Knives only match with no map weapons or equipment. First to the score limit wins.",
          "CTF": "(Capture the flag): Capture the enemy flag to earn a point.",
          "KOTH": "(King of the Hill): Capture the specified zone to earn points."
        },
        tempName: tempName,
        medals: [],
        kills: 0,
        points: [0, 0],
        maxPoints: 10,
        users: [],
        players: 1,
        tempName: tempName,
        mapRespawnPoints: {
          "Cargo": [
            new THREE.Vector3(13.5, 0, -18.5, new THREE.Vector3(0, Math.PI, 0)),
            new THREE.Vector3(17, 0, -2, new THREE.Vector3(0, Math.PI / 2, 0)),
            new THREE.Vector3(-9, 0, -6.5, new THREE.Vector3(0, Math.PI, 0)),
            new THREE.Vector3(7, 0, 16.5, new THREE.Vector3(0, 0, 0))
          ],
          "Lihid": [
            new THREE.Vector3(-18.5, -1, -3, new THREE.Vector3(0, -Math.PI / 2, 0)),
            new THREE.Vector3(-11.5, -3, -4, new THREE.Vector3(0, -Math.PI / 2, 0)),
            new THREE.Vector3(.5, -3, -17.5, new THREE.Vector3(0, -Math.PI, 0)),
            new THREE.Vector3(20, 0, -18.5, new THREE.Vector3(0, Math.PI/2, 0))
          ],
          "Complex": [
            new THREE.Vector3(14.5, 0, -10, new THREE.Vector3(0, Math.PI, 0)),
            new THREE.Vector3(33.5, 0, 0, new THREE.Vector3(0, Math.PI, 0)),
            new THREE.Vector3(18, 0, -36, new THREE.Vector3(0, 0, 0)),
            new THREE.Vector3(-5, 0, -18, new THREE.Vector3(0, 0, 0))
          ],
          "Storage": [
            new THREE.Vector3(36, 3, 10.5, new THREE.Vector3(0, 0, 0)),
            new THREE.Vector3(17.5, 7, -10.5, new THREE.Vector3(0, 0, 0)),
            new THREE.Vector3(4.5, 0, -37, new THREE.Vector3(0, -Math.PI / 2, 0)),
            new THREE.Vector3(42, 0, -14.5, new THREE.Vector3(0, Math.PI / 2, 0))
          ],
          "Aero": [
            new THREE.Vector3(245, -13, -11.5, new THREE.Vector3(0, Math.PI / 2, 0)),
            new THREE.Vector3(161, -11.5, -132.5, new THREE.Vector3(0, Math.PI / 2, 0)),
            new THREE.Vector3(301, 0, 170.5, new THREE.Vector3(0, 0, 0)),
            new THREE.Vector3(420, 6, 80, new THREE.Vector3(0, -Math.PI, 0))
          ]
        },
        map: new URLSearchParams(location.search).get("map") || "Cargo",
        mode: new URLSearchParams(location.search).get("mode") || "Slayer",
        loadout: ["Assault_Rifle", "Glock_19"],
        weapons: [
          {
            name: "Assault_Rifle",
            ammo: "heavy",
            rounds: 56,
            minRounds: 0,
            maxRounds: 56,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2500,
                useDefaultAnimation: true
              }
            },
            useDefaultRunAnimation: true
          },
          {
            name: "Glock_19",
            ammo: "light",
            rounds: 12,
            minRounds: 0,
            maxRounds: 12,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 1500
              },
              full: {
                sound: null,
                time: 2000,
                useDefaultAnimation: true
              }
            },
            useDefaultRunAnimation: false
          },
          {
            name: "Sniper_Rifle",
            ammo: "sniper",
            rounds: 6,
            minRounds: 0,
            maxRounds: 6,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 2500
              },
              full: {
                sound: null,
                time: 2750,
                useDefaultAnimation: false
              }
            },
            useDefaultRunAnimation: true
          },
          {
            name: "Micro_Uzi",
            ammo: "light",
            rounds: 36,
            minRounds: 0,
            maxRounds: 36,
            minClips: 0,
            maxClips: 3,
            clips: 3,
            reloads: {
              easy: {
                sound: null,
                time: 1500
              },
              full: {
                sound: null,
                time: 1750,
                useDefaultAnimation: true
              }
            },
            useDefaultRunAnimation: false
          },
          {
            name: "Auto_Pistol",
            ammo: "light",
            rounds: 50,
            minRounds: 0,
            maxRounds: 50,
            minClips: 0,
            maxClips: 2,
            clips: 2,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2250,
                useDefaultAnimation: true
              }
            },
            useDefaultRunAnimation: true
          },
          {
            name: "Light_Machine_Gun",
            ammo: "heavy",
            rounds: 60,
            minRounds: 0,
            maxRounds: 60,
            minClips: 0,
            maxClips: 2,
            clips: 2,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2200,
                useDefaultAnimation: false
              }
            },
            useDefaultRunAnimation: true
          },
          {
            name: "Shotgun",
            ammo: "shotgun",
            rounds: 15,
            minRounds: 0,
            maxRounds: 15,
            minClips: 0,
            maxClips: 0,
            clips: 0,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2200,
                useDefaultAnimation: true
              }
            },
            useDefaultRunAnimation: true
          },
          {
            name: "Rocket_Pistol",
            ammo: "rocket",
            rounds: 4,
            minRounds: 0,
            maxRounds: 4,
            minClips: 0,
            maxClips: 0,
            clips: 0,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2200,
                useDefaultAnimation: false
              }
            },
            useDefaultRunAnimation: false
          },
          {
            name: "Grenade_Launcher",
            ammo: "grenade",
            rounds: 1,
            minRounds: 0,
            maxRounds: 1,
            minClips: 0,
            maxClips: 0,
            clips: 0,
            reloads: {
              easy: {
                sound: null,
                time: 2000
              },
              full: {
                sound: null,
                time: 2200,
                useDefaultAnimation: false
              }
            },
            useDefaultRunAnimation: false
          },
          {
            name: "Knife",
            ammo: "none",
            rounds: 0,
            minRounds: 0,
            maxRounds: 0,
            minClips: 0,
            maxClips: 0,
            clips: 0,
            reloads: {
              easy: {
                sound: null,
                time: 0
              },
              full: {
                sound: null,
                time: 0,
                useDefaultAnimation: true
              }
            },
            useDefaultRunAnimation: false
          }
        ],
        grenades: {
          min: 0,
          max: 3,
          current: 3,
          types: ["hand"]
        },
        currentWeapon: null,
        primaryWeapon: null,
        secondaryWeapon: null,
        models: {
          "grenade": {
            srcPath: "models/weapons/grenades/hand.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "flash": {
            srcPath: "models/assets/muzzle_flash.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "shell": {
            srcPath: "models/assets/bullet_shell.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "player": {
            srcPath: "models/characters/Steve/scene.gltf",
            object: null,
            callback: function(model) {
              model.scale.set(.75, .75, .75);
              scene.add(model);
              model.traverse(x => x.frustumCulled = false);
              model.position.set(17, 0, -2.25);
              model.getObjectByName("mixamorigRightHand").add(gunHolder);
            },
            mixer: null,
            animations: null
          },
          "Assault_Rifle": {
            srcPath: "models/weapons/dropped/Assault_Rifle.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Glock_19": {
            srcPath: "models/weapons/dropped/Glock_19.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Sniper_Rifle": {
            srcPath: "models/weapons/dropped/Sniper_Rifle.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Micro_Uzi": {
            srcPath: "models/weapons/dropped/Micro_Uzi.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Auto_Pistol": {
            srcPath: "models/weapons/dropped/Auto_Pistol.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Light_Machine_Gun": {
            srcPath: "models/weapons/dropped/Light_Machine_Gun.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Shotgun": {
            srcPath: "models/weapons/dropped/Shotgun.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Rocket_Pistol": {
            srcPath: "models/weapons/dropped/Rocket_Pistol.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Grenade_Launcher": {
            srcPath: "models/weapons/dropped/Grenade_Launcher.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "Knife": {
            srcPath: "models/weapons/dropped/Knife.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "explosion": {
            srcPath: "models/assets/timeframe_explosion.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "smoke": {
            srcPath: "models/assets/smoke_cloud.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          },
          "pointer": {
            srcPath: "models/assets/pointer.glb",
            object: null,
            callback: function() {},
            mixer: null,
            animations: null
          }
        }
      };
      const clock = new THREE.Clock();
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.rotation.order = "YXZ";
      const fillLight1 = new THREE.HemisphereLight(0x4488bb, 0x002244, 0.5);
      fillLight1.position.set(2, 1, 1);
      scene.add(fillLight1);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(-5, 25, -1);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.near = 0.01;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.right = 30;
      directionalLight.shadow.camera.left = -30;
      directionalLight.shadow.camera.top = 30;
      directionalLight.shadow.camera.bottom = -30;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.radius = 4;
      directionalLight.shadow.bias = -0.00006;
      scene.add(directionalLight);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.VSMShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.body.appendChild(renderer.domElement);
      let GRAVITY = 50;
      let NUM_SPHERES = 2;
      let SPHERE_RADIUS = 0.2;
      let STEPS_PER_FRAME = 10;
      const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
      const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xbbbb44 });
      const spheres = [];
      let sphereIdx = 0;
      for (let i = 0; i < NUM_SPHERES; i++) {
        let loader = setInterval(() => {
          if (sandbox.models["grenade"].object != null && spheres.length < 2) {
            const sphere = sandbox.models["grenade"].object.clone();
            if (sphere) {
              scene.add(sphere);
              spheres.push({
                mesh: sphere,
                collider: new THREE.Sphere(new THREE.Vector3(0, - 100, 0), SPHERE_RADIUS),
                velocity: new THREE.Vector3()
              });
            }
            clearInterval(loader);
          }
        });
      }
      const worldOctree = new THREE.Octree();
      const playerCollider = new THREE.Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1, 0), 0.35);
      playerCollider.start.set(13.5, 0.35, -18.5);
      playerCollider.end.set(13.5, 1, -18.5);
      playerCollider.radius = 0.35;
      camera.position.copy(playerCollider.end);
      camera.rotation.set(0, Math.PI, 0);
      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();
      const playerTarget = new THREE.Mesh(new THREE.BoxGeometry(.4, 2.3, .4), new THREE.MeshStandardMaterial({ transparent: true, opacity: 0 }));
      playerTarget.material.depthTest = false;
      playerTarget.material.depthWrite = false;
      scene.add(playerTarget);
      let playerOnFloor = false;
      let mouseTime = 0;
      const keyStates = {};
      const vector1 = new THREE.Vector3();
      const vector2 = new THREE.Vector3();
      const vector3 = new THREE.Vector3();
      document.addEventListener("keydown", (event) => {
        if (!PointerControls.isLocked) return;
        keyStates[event.code] = true;
        if (keyStates["ShiftLeft"] && ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"]))) {
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("RunHealth") <= 0 ? (weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]).play(), weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]).reset(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]), .4), keyStates["ShiftLeft"] = false) : utils.options.set("RunHealth", utils.options.get("RunHealth") - 2);
          });
        }
        if ((keyStates["KeyW"] || keyStates["ArrowUp"]) && !event.repeat) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            direction: "forward"
          });
        }
        if ((keyStates["KeyA"] || keyStates["ArrowLeft"]) && !event.repeat) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            direction: "left"
          });
        }
        if ((keyStates["KeyS"] || keyStates["ArrowDown"]) && !event.repeat) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            direction: "backward"
          });
        }
        if ((keyStates["KeyD"] || keyStates["ArrowRight"]) && !event.repeat) {
          call("walk", {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
            direction: "right"
          });
        }
        if ((keyStates["KeyW"] || keyStates["ArrowUp"]) && !event.repeat) {
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            if (keyStates["ShiftLeft"]) {
              utils.options.get("Reloading") || (weapon.mixer.clipAction(weapon.animations[6]).crossFadeTo(weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]), .4), weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]).reset(), weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]).play());
            } else {
              utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
            }
          });
        }
        if (keyStates["KeyR"] && !event.repeat) {
          utils.weapons.reload();
        }
        if (keyStates["KeyI"] && !event.repeat) {
          utils.options.get("Zoomed") ? utils.camera.zoomOut() : utils.camera.zoomIn();
        }
        if (keyStates["KeyB"] && !event.repeat) {
          utils.weapons.punch();
        }
        if (keyStates["KeyF"] && !event.repeat) {
          document.dispatchEvent(new MouseEvent("mousedown"));
        }
        if (keyStates["KeyY"] && !event.repeat) {
          utils.weapons.switch();
        }
        if (keyStates["KeyM"] && !event.repeat) {
          utils.weapons.grenades.throw();
        }
      });
      document.addEventListener("keyup", (event) => {
        call("walk", {
          positive: false
        });
        if (!PointerControls.isLocked) return;
        clearInterval(utils.options.get("Bobbing"));
        utils.options.set("Bobbing", null);
        sandbox.weapons.forEach(weapon => {
          weapon.mixer.clipAction(weapon.animations[6]).stop(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]), .4), weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]).play();
          if ((keyStates["KeyW"] || keyStates["KeyS"] || keyStates["KeyA"] || keyStates["KeyD"]) || (keyStates["ArrowUp"] || keyStates["ArrowDown"] || keyStates["ArrowLeft"] || keyStates["ArrowRight"])) {
            weapon.mixer.clipAction(weapon.animations[6]).stop();
            document.querySelector("#walkingSound").pause();
            document.querySelector("#walkingSound").currentTime = 0;
          }
          if (keyStates["KeyF"]) {
            document.dispatchEvent(new MouseEvent("mouseup"));
          }
        });
        keyStates[event.code] = false;
      });
      renderer.domElement.addEventListener("mousedown", () => {
        if (document.pointerLockElement != null) return;
        document.body.requestPointerLock();
        PointerControls.lock();
        mouseTime = performance.now();
      });
      document.addEventListener("mouseup", () => {
        if (!PointerControls.isLocked) return;
        PointerControls.lock();
      });
      document.body.addEventListener("mousemove", (event) => {
        if (!PointerControls.isLocked) return;
        call("turn", {
          rotation: new THREE.Vector2(camera.rotation.x, camera.rotation.y),
          x: camera.position.x,
          y: camera.position.y,
          z: camera.position.z,
        });
      });
      window.addEventListener("resize", onWindowResize);
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        weaponCamera.aspect = window.innerWidth / window.innerHeight;
        weaponCamera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        weaponRenderer.setSize(window.innerWidth, window.innerHeight);
      }
      gameControl.on("connect", (controller) => {
        window.GamepadController = controller;
      });
      function pollGamepad() {
        let sensitivity = .025;
        let jumped = false;
        let shooted = false;
        if (!GamepadControls.isLocked || !navigator.getGamepads()[0]) return;
        gamepad = navigator.getGamepads()[0];
        if (gamepad.axes[3] > 0.20) {
          rotateCamera(-gamepad.axes[3] * sensitivity, 0);
        }
        if (gamepad.axes[3] < -0.20) {
          rotateCamera(-gamepad.axes[3] * sensitivity, 0);
        }
        if (gamepad.axes[2] < -0.20) {
          rotateCamera(0, -gamepad.axes[2] * sensitivity);
        }
        if (gamepad.axes[2] > 0.20) {
          rotateCamera(0, -gamepad.axes[2] * sensitivity);
        }
        if (gamepad.axes[1] > 0.20) {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: "s", code: "KeyS" }));
        } else {
          document.dispatchEvent(new KeyboardEvent("keyup", { key: "s", code: "KeyS" }));
        }
        if (gamepad.axes[1] < -0.20) {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: "w", code: "KeyW" }));
        } else {
          document.dispatchEvent(new KeyboardEvent("keyup", { key: "w", code: "KeyW" }));
        }
        if (gamepad.axes[0] < -0.20) {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: "a", code: "KeyA" }));
        } else {
          document.dispatchEvent(new KeyboardEvent("keyup", { key: "a", code: "KeyA" }));
        }
        if (gamepad.axes[0] > 0.20) {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: "d", code: "KeyD" }));
        } else {
          document.dispatchEvent(new KeyboardEvent("keyup", { key: "d", code: "KeyD" }));
        }
        GamepadController.on("button0", () => {}).before("button0", () => {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: " ", code: "Space" }));
        }).after("button0", () => {
          document.dispatchEvent(new KeyboardEvent("keyup", { key: " ", code: "Space" }));
        });
        GamepadController.on("button3", () => {}).before("button3", () => {
          keyStates["ShiftLeft"] ? document.dispatchEvent(new KeyboardEvent("keyup", { key: "Shift", code: "ShiftLeft" })) : document.dispatchEvent(new KeyboardEvent("keydown", { key: "Shift", code: "ShiftLeft" }));
        });
        GamepadController.on("button4", () => {}).before("button4", () => {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: "y", code: "KeyY" }));
          document.dispatchEvent(new KeyboardEvent("keyup", { key: "y", code: "KeyY" }));
        });
        GamepadController.on("button14", () => {}).before("button14", () => {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: "i", code: "KeyI" }));
          document.dispatchEvent(new KeyboardEvent("keyup", { key: "i", code: "KeyI" }));
        });
        GamepadController.on("button16", () => {}).before("button16", () => {
          document.dispatchEvent(new KeyboardEvent("keydown", { key: "f", code: "KeyF" }));
        }).after("button16", () => {
          document.dispatchEvent(new KeyboardEvent("keyup", { key: "f", code: "KeyF" }));
        });
      }
      function rotateCamera(dx, dy) {
        let x = camera.rotation.x;
        camera.rotateX(-x);
        camera.rotateY(dy);
        if (Math.abs(dx + x) > Math.PI / 2 - 0.05) {
          camera.rotateX(x);
        } else {
          camera.rotateX(x + dx);
        }
        camera.rotation.z = 0;
        call("turn", {
          rotation: new THREE.Vector2(camera.rotation.x, camera.rotation.y),
          x: camera.position.x,
          y: camera.position.y,
          z: camera.position.z,
        });
      }
      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;
        if (result) {
          if (utils.options.get("Starting")) {
            if (document.querySelector(".before-ui").style.visibility == "visible") {
              let wait = setInterval(() => {
                if (document.querySelector(".before-ui").style.visibility == "hidden") {
                  weaponScene.add(sandbox.currentWeapon);
                  camera.fov = 70;
                  camera.updateProjectionMatrix();
                  weaponCamera.fov = 70;
                  weaponCamera.updateProjectionMatrix();
                  document.querySelector(".ui").style.visibility = "visible";
                  PointerControls.isLocked = true;
                  GamepadControls.isLocked = true;
                  utils.weapons.data(sandbox.currentWeapon).then(x => {
                    x.mixer.clipAction(x.animations[0]).loop = THREE.LoopOnce;
                    x.mixer.clipAction(x.animations[0]).reset();
                    x.mixer.clipAction(x.animations[0]).play();
                  });
                  utils.options.set("Starting", false);
                  clearInterval(wait);
                }
              });
            } else {
              weaponScene.add(sandbox.currentWeapon);
              camera.fov = 70;
              camera.updateProjectionMatrix();
              weaponCamera.fov = 70;
              weaponCamera.updateProjectionMatrix();
              document.querySelector(".ui").style.visibility = "visible";
              PointerControls.isLocked = true;
              GamepadControls.isLocked = true;
              utils.weapons.data(sandbox.currentWeapon).then(x => {
                x.mixer.clipAction(x.animations[0]).loop = THREE.LoopOnce;
                x.mixer.clipAction(x.animations[0]).reset();
                x.mixer.clipAction(x.animations[0]).play();
              });
              utils.options.set("Starting", false);
            }
          }
          playerOnFloor = result.normal.y > 0;
          if (!playerOnFloor) {
            playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
          }
          playerCollider.translate(result.normal.multiplyScalar(result.depth));
        }
      }
      function updatePlayer(deltaTime) {
        let damping = Math.exp(- 4 * deltaTime) - 1;
        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * (deltaTime);
          damping *= 0.1;
        }
        playerVelocity.addScaledVector(playerVelocity, damping);
        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);
        playerCollisions();
        camera.position.copy(playerCollider.end);
      }
      function playerSphereCollision(sphere) {
        const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);
        const sphere_center = sphere.collider.center;
        const r = playerCollider.radius + sphere.collider.radius;
        const r2 = r * r;
        for (const point of [playerCollider.start, playerCollider.end, center]) {
          const d2 = point.distanceToSquared(sphere_center);
          if (d2 < r2) {
            const normal = vector1.subVectors(point, sphere_center).normalize();
            const v1 = vector2.copy(normal).multiplyScalar(normal.dot(playerVelocity));
            const v2 = vector3.copy(normal).multiplyScalar(normal.dot(sphere.velocity));
            playerVelocity.add(v2).sub(v1);
            sphere.velocity.add(v1).sub(v2);
            const d = (r - Math.sqrt(d2)) / 2;
            sphere_center.addScaledVector(normal, - d);
          }
        }
      }
      function spheresCollisions() {
        for (let i = 0, length = spheres.length; i < length; i++) {
          const s1 = spheres[i];
          for (let j = i + 1; j < length; j++) {
            const s2 = spheres[j];
            const d2 = s1.collider.center.distanceToSquared(s2.collider.center);
            const r = s1.collider.radius + s2.collider.radius;
            const r2 = r * r;
            if (d2 < r2) {
              const normal = vector1.subVectors(s1.collider.center, s2.collider.center).normalize();
              const v1 = vector2.copy(normal).multiplyScalar(normal.dot(s1.velocity));
              const v2 = vector3.copy(normal).multiplyScalar(normal.dot(s2.velocity));
              s1.velocity.add(v2).sub(v1);
              s2.velocity.add(v1).sub(v2);
              const d = (r - Math.sqrt(d2)) / 2;
              s1.collider.center.addScaledVector(normal, d);
              s2.collider.center.addScaledVector(normal, - d);
            }
          }
        }
      }
      function updateSpheres(deltaTime) {
        spheres.forEach(sphere => {
          sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);
          const result = worldOctree.sphereIntersect(sphere.collider);
          if (result) {
            sphere.hits || (sphere.hits = 0);
            if (scene.children.indexOf(sphere.mesh) > -1 && sphere.hits < 4) {
              let hits = ["ricochet1", "ricochet2", "ricochet3"];
              sphere.hits++;
              new THREE.Sound("sounds/" + hits[Math.floor(Math.random() * hits.length)] + ".mp3", sphere.mesh);
            }
            sphere.velocity.addScaledVector(result.normal, - result.normal.dot(sphere.velocity) * 1.5);
            sphere.collider.center.add(result.normal.multiplyScalar(result.depth));
          } else {
            sphere.velocity.y -= (GRAVITY * deltaTime + .01);
          }
          const damping = Math.exp(- 1.5 * deltaTime) - 1.003;
          sphere.velocity.addScaledVector(sphere.velocity, damping);
          playerSphereCollision(sphere);
        });
        spheresCollisions();
        for (const sphere of spheres) {
          sphere.mesh.position.copy(sphere.collider.center);
        }
      }
      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }
      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }
      function collision(e, B) {
        let firstBB = new THREE.Box3().setFromObject(e);
        let secondBB = new THREE.Box3().setFromObject(B);
        return firstBB.intersectsBox(secondBB)
      }
      const loader = new THREE.GLTFLoader();
      loader.load("models/maps/" + sandbox.map + ".glb", (gltf) => {
        map = gltf.scene;
        worldOctree.fromGraphNode(gltf.scene);
        scene.add(gltf.scene);
        gltf.scene.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material.map) {
              child.material.map.anisotropy = 4;
            }
          }
        });
        function isSustained() {
          return new Promise(function(resolve, reject) {
            let t = camera.position;
            setTimeout(() => t.y - .02 >= camera.position.y ? resolve(!true) : resolve(!false), 100);
          });
        }
        let animated = false;
        let checkSustained = setInterval(() => {
          isSustained().then(sustained => {
            if (sustained) {
              !animated && animate();
              animated = true;
              clearInterval(checkSustained);
            }
          });
        });
        updateShadows();
      });
      function updateShadows() {
        renderer.shadowMap.needsUpdate = true;
      }
      function teleportPlayerIfOob() {
        if (camera.position.y <= -25 && !utils.options.get("Starting")) {
          playerCollider.start.set(13.5, 0.35, -18.5);
          playerCollider.end.set(13.5, 1, -18.5);
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0, Math.PI, 0);
        }
      }
      function controls(deltaTime) {
        const speedDelta = .025;
        if (keyStates["KeyW"] || keyStates["ArrowUp"]) {
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getForwardVector().multiplyScalar(keyStates["ShiftLeft"] ? speedDelta + .05 : speedDelta));
          document.querySelector("#walkingSound").play();
        }
        if (keyStates["KeyS"] || keyStates["ArrowDown"]) {
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
          document.querySelector("#walkingSound").play();
        }
        if (keyStates["KeyA"] || keyStates["ArrowLeft"]) {
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
          document.querySelector("#walkingSound").play();
        }
        if (keyStates["KeyD"] || keyStates["ArrowRight"]) {
          utils.options.get("Bobbing") || utils.options.set("Bobbing", setInterval(() => utils.camera.shake(.4, 50), 400));
          playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
          utils.weapons.data(sandbox.currentWeapon).then(weapon => {
            utils.options.get("Reloading") || weapon.mixer.clipAction(weapon.animations[6]).play();
          });
          document.querySelector("#walkingSound").play();
        }
        if (playerOnFloor) {
          if (keyStates["Space"]) {
            playerVelocity.y = 12;
          }
        }
      }
      let raycaster = new THREE.Raycaster();
      raycastTargets = [playerTarget];
      intersection = null;
      function animate() {
        requestAnimationFrame(animate);
        pollGamepad();
        typeof sandbox.users[0] != "undefined" && (document.querySelector(".player1").querySelector(".username").textContent = (sandbox.users[0].username || sandbox.tempName).slice(0, 13));
        typeof sandbox.users[1] != "undefined" && (document.querySelector(".player2").querySelector(".username").textContent = (sandbox.users[1].username || sandbox.tempName).slice(0, 13));
        document.querySelector(".player1").querySelector(".score").textContent = sandbox.points[0];
        document.querySelector(".player2").querySelector(".score").textContent = sandbox.points[1];
        if (sandbox.points[0] >= sandbox.maxPoints) {
          if (gametime.user.position == 1) {
            if (!utils.options.get("GameOver")) {
              utils.options.set("GameOver", true);
              let points = (sandbox.points[0] + sandbox.medals.length) * 10;
              utils.ui.dialog("Game over", "You win! You earned " + sandbox.medals.length + " medals and " + points + " points", 10000);
              utils.respawn = () => {};
              let rewards = {
                points: points,
                medals: sandbox.medals,
                kills: sandbox.kills
              };
              localStorage.setItem("temp-rewards", JSON.stringify(rewards));
              setTimeout(() => location.replace("/"), 5000);
            }
          } else {
            if (!utils.options.get("GameOver")) {
              utils.options.set("GameOver", true);
              let points = 50;
              utils.ui.dialog("Game over", "You lose... But you earned " + points + " points for playing!", 10000);
              utils.respawn = () => {};
              let rewards = {
                points: points,
                medals: [],
                kills: sandbox.kills
              };
              localStorage.setItem("temp-rewards", JSON.stringify(rewards));
              setTimeout(() => location.replace("/"), 5000);
            }
          }
        } else if (sandbox.points[1] >= sandbox.maxPoints) {
          if (gametime.user.position == 2) {
            if (!utils.options.get("GameOver")) {
              utils.options.set("GameOver", true);
              let points = (sandbox.points[1] + sandbox.medals.length) * 10;
              utils.ui.dialog("Game over", "You win! You earned " + sandbox.medals.length + " medals and " + points + " points", 10000);
              utils.respawn = () => {};
              let rewards = {
                points: points,
                medals: sandbox.medals,
                kills: sandbox.kills
              };
              localStorage.setItem("temp-rewards", JSON.stringify(rewards));
              setTimeout(() => location.replace("/"), 5000);
            }
          } else {
            if (!utils.options.get("GameOver")) {
              utils.options.set("GameOver", true);
              let points = 50;
              utils.ui.dialog("Game over", "You lose... But you earned " + points + " points for playing!", 10000);
              utils.respawn = () => {};
              let rewards = {
                points: points,
                medals: [],
                kills: sandbox.kills
              };
              localStorage.setItem("temp-rewards", JSON.stringify(rewards));
              setTimeout(() => location.replace("/"), 5000);
            }
          }
        }
        camera.updateMatrixWorld();
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        let intersections = raycaster.intersectObjects(raycastTargets);
        (intersection = intersections[0] || null);
        if (intersection) {
          if (utils.options.get("Zoomed")) {
            !document.querySelector(".crosshair").src.includes("crosshair_zoomed_intersected.png") && (document.querySelector(".crosshair").src = "images/icons/ui/crosshair_zoomed_intersected.png");
          } else {
            !document.querySelector(".crosshair").src.includes("crosshair_intersected.png") && (document.querySelector(".crosshair").src = "images/icons/ui/crosshair_intersected.png");
          }
        } else {
          if (utils.options.get("Zoomed")) {
            !document.querySelector(".crosshair").src.includes("crosshair_zoomed.png") && (document.querySelector(".crosshair").src = "images/icons/ui/crosshair_zoomed.png");
          } else {
            !document.querySelector(".crosshair").src.includes("crosshair.png") && (document.querySelector(".crosshair").src = "images/icons/ui/crosshair.png");
          }
        }
        typeof playerTarget != "undefined" && sandbox.models["player"].object != null && playerTarget.position.copy(sandbox.models["player"].object.position);
        if (utils.options.get("PlayerWalkingForward")) {
          sandbox.models["player"].object.translateZ(clock.getDelta() * 35);
        }
        if (utils.options.get("PlayerWalkingBackward")) {
          sandbox.models["player"].object.translateZ(-(clock.getDelta() * 35));
        }
        if (utils.options.get("PlayerWalkingLeft")) {
          sandbox.models["player"].object.translateX(clock.getDelta() * 35);
        }
        if (utils.options.get("PlayerWalkingRight")) {
          sandbox.models["player"].object.translateX(-(clock.getDelta() * 35));
        }
        sun.position.set(camera.position.x, 50, camera.position.z);
        utils.options.get("RunHealth") >= 100 ? utils.options.set("RunHealth", 100) : keyStates["ShiftLeft"] || utils.options.set("RunHealth", utils.options.get("RunHealth") + 1);
        document.querySelector(".run-health").style.width = (utils.options.get("RunHealth") <= 0 ? 0 : utils.options.get("RunHealth")) + "%";
        document.querySelector(".run-health").querySelector("span").querySelector("span").textContent = (utils.options.get("RunHealth") <= 0 ? 0 : utils.options.get("RunHealth"));
        document.querySelector(".health").style.width = (utils.options.get("Health") <= 0 ? 0 : utils.options.get("Health").toFixed(0)) + "%";
        document.querySelector(".health").querySelector("span").querySelector("span").textContent = (utils.options.get("Health") <= 0 ? 0 : utils.options.get("Health").toFixed(0));
        document.querySelector(".current-grenades").textContent = sandbox.grenades.current;
        sandbox.currentWeapon && utils.weapons.data(sandbox.currentWeapon).then(weapon => {
          document.querySelector(".current-ammo").textContent = (weapon.maxRounds * (weapon.maxClips + 1)) - weapon.roundsUsed;
        });
        if (sandbox.primaryWeapon != null && sandbox.secondaryWeapon != null && utils.options.get("WeaponLocked")) {
          sandbox.primaryWeapon.position.copy(camera.position);
          sandbox.primaryWeapon.rotation.copy(camera.rotation);
          sandbox.primaryWeapon.rotateY(Math.PI);
          sandbox.primaryWeapon.translateX(-.1);
          sandbox.primaryWeapon.translateZ(.3);
          sandbox.primaryWeapon.translateY(-.15);
          sandbox.secondaryWeapon.position.copy(camera.position);
          sandbox.secondaryWeapon.rotation.copy(camera.rotation);
          sandbox.secondaryWeapon.rotateY(Math.PI);
          sandbox.secondaryWeapon.translateX(-.1);
          sandbox.secondaryWeapon.translateZ(.3);
          sandbox.secondaryWeapon.translateY(-.15);
        }
        const deltaTime = clock.getDelta();
        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          controls(deltaTime);
          updatePlayer(deltaTime);
          updateSpheres(deltaTime);
          teleportPlayerIfOob();
        }
        renderer.render(scene, camera);
      }
      sandbox.weapons.forEach(x => {
        load(`models/weapons/${x.name}.glb`, (model) => {
          x.object = model.scene;
          x.object.scale.set(.01, .01, .01);
          x.animations = model.animations;
          x.mixer = new THREE.AnimationMixer(model.scene);
          x.roundsUsed = 0;
          let weapon = x;
          weapon.mixer.clipAction(weapon.animations[6]).stop(), weapon.mixer.clipAction(weapon.animations[6]).crossFadeFrom(weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]), .4), weapon.mixer.clipAction(weapon.animations[weapon.useDefaultRunAnimation ? 7 : 9]).play();
          if (x.name == sandbox.loadout[0]) {
            sandbox.primaryWeapon = x.object;
            sandbox.currentWeapon = x.object;
            weaponScene.add(sandbox.primaryWeapon);
          }
          if (x.name == sandbox.loadout[1]) {
            sandbox.secondaryWeapon = x.object;
          }
        });
      });
      Object.keys(sandbox.models).forEach(x => {
        load(sandbox.models[x].srcPath, (model) => {
          sandbox.models[x].object = model.scene;
          sandbox.models[x].mixer = new THREE.AnimationMixer(model.scene);
          sandbox.models[x].animations = model.animations;
          sandbox.models[x].callback(model.scene);
        });
      });
      const weaponRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      weaponRenderer.setPixelRatio(window.devicePixelRatio);
      weaponRenderer.setSize(window.innerWidth, window.innerHeight);
      weaponRenderer.outputEncoding = THREE.sRGBEncoding;
      weaponRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.body.appendChild(weaponRenderer.domElement);
      const weaponScene = new THREE.Scene();
      const weaponCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      const PointerControls = new PointerLockControls(camera, renderer.domElement);
      const GamepadControls = {
        isLocked: true
      };
      const TouchControls = new THREE.TouchControls(camera, renderer.domElement);
      PointerControls.isLocked = false;
      GamepadControls.isLocked = false;
      PointerControls.pointerSpeed = 2;
      TouchControls.speed = 3;
      weaponCamera.rotation.order = "YXZ";
      let pointers = {};
      let ammoBoxes = [];
      function weaponAnimate() {
        const delta = clock.getDelta();
        requestAnimationFrame(weaponAnimate);
        Object.values(pointers).forEach(x => {
          let k = (camera.position.distanceTo(x.position) > 4 ? 4 : camera.position.distanceTo(x.position)) / 100;
          x.scale.set(k, k, k);
          x.lookAt(camera.position);
        });
        space.position.copy(camera.position);
        space.rotateY(.00025);
        space.rotateX(.0001);
        sun.position.set(camera.position.x, 50, camera.position.z);
        weaponCamera.position.copy(camera.position);
        weaponCamera.rotation.copy(camera.rotation);
        if (sandbox.primaryWeapon != null && sandbox.secondaryWeapon != null && utils.options.get("WeaponLocked")) {
          sandbox.primaryWeapon.position.copy(weaponCamera.position);
          sandbox.primaryWeapon.rotation.copy(weaponCamera.rotation);
          sandbox.primaryWeapon.rotateY(Math.PI);
          sandbox.primaryWeapon.translateX(-.1);
          sandbox.primaryWeapon.translateZ(.3);
          sandbox.primaryWeapon.translateY(-.15);
          sandbox.secondaryWeapon.position.copy(weaponCamera.position);
          sandbox.secondaryWeapon.rotation.copy(weaponCamera.rotation);
          sandbox.secondaryWeapon.rotateY(Math.PI);
          sandbox.secondaryWeapon.translateX(-.1);
          sandbox.secondaryWeapon.translateZ(.3);
          sandbox.secondaryWeapon.translateY(-.15);
        }
        weaponFillLight1.position.copy(fillLight1.position);
        weaponFillLight1.rotation.copy(fillLight1.rotation);
        weaponRenderer.render(weaponScene, weaponCamera);
        sandbox.weapons.forEach(x => x.mixer && (x.mixer.update(delta), utils.options.get("Reloading") || (x.mixer.clipAction(x.animations[1]).play())));
        Object.values(sandbox.models).forEach(x => (x.mixer && (x.mixer.update(delta))));
      }
      weaponRenderer.domElement.style.position = "absolute";
      weaponRenderer.domElement.style.left = "0";
      weaponRenderer.domElement.style.top = "0";
      weaponRenderer.domElement.style.pointerEvents = "none";
      weaponRenderer.domElement.style.zIndex = "9999";
      weaponRenderer.setClearAlpha();
      weaponRenderer.setClearColor(0x000000, 0);
      let weaponFillLight1 = fillLight1.clone();
      let weaponDirectionalLight = directionalLight.clone();
      weaponScene.add(weaponFillLight1);
      weaponScene.add(weaponDirectionalLight);
      weaponAnimate();
	    // Performance optimization
	    renderer.shadowMap.autoUpdate = false;
	    renderer.setPixelRatio(1.2);
	    weaponRenderer.setPixelRatio(1.1);

	    // Multiplayer setup
      gametime.set("key", "pub-c-3740053e-fec0-4122-bfc4-9214ccfff37d", "sub-c-e4d0d472-66a4-49dc-b796-830b9e56a653");
      gametime.set("channel", new URLSearchParams(location.search).get("lobby"));

      // Game setup
      if (sandbox.mode == "Slayer") {
        sandbox.players = 2;
      }
      if (sandbox.mode == "Teams") {
        sandbox.players = 4;
      }
      if (sandbox.mode == "Fiesta") {
        sandbox.players = 2;
        sandbox.loadout = [sandbox.weapons[Math.floor(Math.random() * sandbox.weapons.length)].name, sandbox.weapons[Math.floor(Math.random() * sandbox.weapons.length)].name];
        utils.weapons.create.disable();
      }
      if (sandbox.mode == "Snipers") {
        sandbox.players = 2;
        sandbox.loadout = ["Sniper_Rifle", "Sniper_Rifle"];
        utils.weapons.create.disable();
      }
      if (sandbox.mode == "Oddball") {
        sandbox.players = 2;
      }
      if (sandbox.mode == "Fistfight") {
        sandbox.players = 2;
        sandbox.loadout = ["Knife", "Knife"];
        utils.weapons.create.disable();
      }
      if (sandbox.mode == "Ctf") {
        sandbox.players = 2;
      }
      if (sandbox.mode == "Koth") {
        sandbox.players = 2;
      }
      
      if (sandbox.map == "Cargo") {
        sun = new THREE.Mesh(new THREE.CircleGeometry(10), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/sun.png"), transparent: true }));
        scene.background = new THREE.Color(0x88ccee);
        sun.position.set(0, 50, 0);
        sun.rotateX(1);
        scene.add(sun);
        scene.fog = new THREE.Fog(0x88ccee, 0, 100);
        utils.weapons.create("Grenade_Launcher", new THREE.Vector3(10, 0, -8), false);
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(9.5, 0, -16));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(14, 0, 1.5));
      } else if (sandbox.map == "Storage") {
        sun = new THREE.Mesh(new THREE.CircleGeometry(10), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/sun.png"), transparent: true }));
        scene.background = new THREE.Color(0x88ccee);
        sun.position.set(0, 50, 0);
        sun.rotateX(1);
        scene.add(sun);
        scene.fog = new THREE.Fog(0xffffff, 0, 90);
        utils.weapons.create("Auto_Pistol", new THREE.Vector3(-3.5, 0, 16));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(-7, 0, -4.5));
        utils.weapons.create("Rocket_Pistol", new THREE.Vector3(-7, 3.8, 20), false);
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(23, 0, 20));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(10, 3.8, -34.5));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(42, 0,  -12));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(18, 0,  -24));
      } else if (sandbox.map == "Lihid") {
        sun = new THREE.Mesh(new THREE.CircleGeometry(10), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/sun.png"), transparent: true }));
        scene.background = new THREE.Color(0x88ccee);
        sun.position.set(0, 50, 0);
        sun.rotateX(1);
        scene.add(sun);
        scene.fog = new THREE.Fog(0xbbba90, 0, 80);
        utils.weapons.create("Rocket_Pistol", new THREE.Vector3(20.5, -.2, -16.5));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(10.5, -1.4, -8));
        utils.weapons.create("Auto_Pistol", new THREE.Vector3(-2, -1.4, 15));
        utils.weapons.create("Sniper_Rifle", new THREE.Vector3(10, -1.4, 19));
        utils.weapons.create("Light_Machine_Gun", new THREE.Vector3(14, -1.4, 0));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(27.5, .2, 1.6));
        utils.weapons.create("Micro_Uzi", new THREE.Vector3(28, -.4, 7.5));
      } else if (sandbox.map == "Aero") {
        GRAVITY = 10;
        let sphere = new THREE.SphereGeometry(500, 60, 40);
        space = new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/space.png") }));
        space.material.map.generateMipmaps = false;
        space.material.map.minFilter = THREE.LinearMipMapLinearFilter;
        space.material.map.needsUpdate = true;
        scene.background = null;
        space.material.side = THREE.DoubleSide;
        scene.add(space);
        scene.fog = null;
      } else if (sandbox.map == "Complex") {
        let sphere = new THREE.SphereGeometry(500, 60, 40);
        sky = new THREE.Mesh(sphere, new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("images/textures/clouds.png") }));
        sky.material.map.generateMipmaps = false;
        sky.material.map.minFilter = THREE.LinearMipMapLinearFilter;
        sky.material.map.needsUpdate = true;
        scene.background = null;
        sky.material.side = THREE.DoubleSide;
        scene.add(sky);
        scene.fog = null;
      }
      document.addEventListener("mousedown", function(event) {
        if (!PointerControls.isLocked) return;
        utils.weapons.data(sandbox.currentWeapon).then(weapon => {
          if (weapon.name == "Assault_Rifle") {
            utils.options.set("RapidFire", true);
          }
          if (weapon.name == "Glock_19") {
            utils.weapons.shoot();
          }
          if (weapon.name == "Sniper_Rifle") {
            utils.weapons.shoot(1);
          }
          if (weapon.name == "Micro_Uzi") {
            utils.weapons.shoot(3);
          }
          if (weapon.name == "Auto_Pistol") {
            utils.options.set("RapidFire", true);
          }
          if (weapon.name == "Light_Machine_Gun") {
            utils.options.set("RapidFire", true);
          }
          if (weapon.name == "Shotgun") {
            utils.weapons.shoot(8, false, false, 10);
            new THREE.Sound("sounds/guns/Shotgun/fire.mp3", sandbox.currentWeapon, () => {}, false);
            utils.weapons.data(sandbox.currentWeapon).then(weapon => {
              weapon.rounds--;
              weapon.roundsUsed++;
            });
          }
          if (weapon.name == "Rocket_Pistol") {
            utils.weapons.shoot(1);
          }
          if (weapon.name == "Grenade_Launcher") {
            utils.weapons.shoot(1);
          }
          if (weapon.name == "Knife") {
            if (utils.options.get("Punching")) return;
            let swing1;
            let e = sandbox.currentWeapon.children[0].rotation;
            let d = sandbox.currentWeapon.children[0].position;
            let t = 0;
            let swing = setInterval(() => {
              if (t >= .2) return swing1 = setInterval(() => {
              if (t <= 0) return sandbox.currentWeapon.children[0].rotation.copy(e), sandbox.currentWeapon.children[0].position.copy(d), clearInterval(swing1);
              t += -.005;
              sandbox.currentWeapon.children[0].rotateX(-.02);
              sandbox.currentWeapon.children[0].translateY(.2);
            }), clearInterval(swing);
              t += .005;
              sandbox.currentWeapon.children[0].rotateX(.02);
              sandbox.currentWeapon.children[0].translateY(-.2);
            });
            utils.weapons.punch(200);
          }
        });
      });
      document.addEventListener("mouseup", function(event) {
        utils.options.set("RapidFire", false);
      });
      let rapidFire = setInterval(function() {
        if (utils.options.get("RapidFire")) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (x.name == "Assault_Rifle") utils.weapons.shoot();
          });
        }
      }, 75);
      let rapidFire1 = setInterval(function() {
        if (utils.options.get("RapidFire")) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (x.name == "Auto_Pistol") utils.weapons.shoot();
          });
        }
      }, 30);
      let rapidFire2 = setInterval(function() {
        if (utils.options.get("RapidFire")) {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            if (x.name == "Light_Machine_Gun") utils.weapons.shoot();
          });
        }
      }, 100);
      utils.options.set("CanFire", true);
      utils.options.set("Reloading", false);
      utils.options.set("HealthRegenerator", null);
      utils.options.set("Health", 100);
      utils.options.set("RunHealth", 100);
      utils.options.set("WeaponLocked", true);
      utils.options.set("Zoomed", false);
      utils.options.set("TouchDevice", window.matchMedia("(pointer: coarse)").matches);
      utils.options.set("TempObjects", []);
      utils.options.set("Bobbing", null);
      utils.options.set("WeaponBoxes", {});
      utils.options.set("TouchingWeapon", null);
      utils.options.set("PlayerWalkingForward", false);
      utils.options.set("PlayerWalkingBackward", false);
      utils.options.set("PlayerWalkingLeft", false);
      utils.options.set("PlayerWalkingRight", false);
      utils.options.set("Starting", false);
      utils.options.set("Killed", false);
      utils.options.set("OtherKilled", false);
      utils.options.set("GameOver", false);
      utils.options.set("ActiveMedals", 0);
      utils.options.set("BotStatus", {
        health: 100,
        grenades: 3
      });

      /* Multiplayer setup */
      character = {
        loadout: sandbox.loadout
      };
      let loadout = setInterval(() => {
        if (sandbox.models[character.loadout[0]].object && sandbox.models[character.loadout[1]].object) {
          character.primaryWeapon = sandbox.models[character.loadout[0]].object.clone();
          character.currentWeapon = character.primaryWeapon;
          character.secondaryWeapon = sandbox.models[character.loadout[1]].object.clone();
          character.primaryWeapon.scale.set(10, 10, 10);
          character.primaryWeapon.position.set(0, 0, 0);
          character.secondaryWeapon.scale.set(10, 10, 10);
          character.secondaryWeapon.position.set(0, 0, 0);
          gunHolder.add(character.primaryWeapon);
          return clearInterval(loadout);
        }
      });
      gametime.make("playerAction");
      gametime.on("playerAction", function(message) {
        let data = message.split(",");
        let user = data[0];
        let action = data[1];
        let metadata = JSON.parse(data.splice(2).join(",").replace(/(\')/gi, "\""));
        let isUser = user == gametime.user.position;
        if (!isUser && action == "walk") {
          typeof metadata.positive == "undefined" && (metadata.positive = true);
          if (metadata.positive) {
            sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).play();
            sandbox.models["player"].object.position.x = metadata.x;
            sandbox.models["player"].object.position.y = metadata.y - 1;
            sandbox.models["player"].object.position.z = metadata.z;
            utils.options.set("PlayerWalking" + (metadata.direction[0].toUpperCase() + metadata.direction.split("").splice(1).join("")), true);
          } else {
            sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).stop();
            sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).reset();
            utils.options.set("PlayerWalkingForward", false);
            utils.options.set("PlayerWalkingBackward", false);
            utils.options.set("PlayerWalkingLeft", false);
            utils.options.set("PlayerWalkingRight", false);
          }
        }
        if (!isUser && action == "turn") {
          sandbox.models["player"].object.rotation.order = "YXZ";
          sandbox.models["player"].object.rotation.y = metadata.rotation.y;
          sandbox.models["player"].object.position.x = metadata.x;
          sandbox.models["player"].object.position.y = metadata.y - 1;
          sandbox.models["player"].object.position.z = metadata.z;
          sandbox.models["player"].object.rotateY(Math.PI);
          sandbox.models["player"].object.getObjectByName("mixamorigNeck").rotation.x = (1.5 - metadata.rotation.x) + (Math.PI / 2);
          sandbox.models["player"].object.getObjectByName("mixamorigNeck").rotation.x += -Math.PI;
        }
        if (!isUser && action == "info") {
          if (sandbox.users.find(x => x.username == metadata.username)) return;
          sandbox.users.push({
            player: sandbox.users.length + 1,
            username: metadata.username,
            loadout: character.loadout
          });
          character.loadout = metadata.loadout;
        }
        if (!isUser && action == "switch") {
          if (character.currentWeapon == character.primaryWeapon) {
            gunHolder.remove(character.primaryWeapon);
            gunHolder.add(character.secondaryWeapon);
            character.currentWeapon = character.secondaryWeapon;
          } else {
            gunHolder.remove(character.secondaryWeapon);
            gunHolder.add(character.primaryWeapon);
            character.currentWeapon = character.primaryWeapon;
          }
        }
        if (!isUser && action == "shoot") {
          let flash = sandbox.models["flash"].object.clone();
          new THREE.Sound("sounds/guns/" + metadata.weapon + "/fire.mp3", sandbox.currentWeapon, () => {}, false);
          flash.children[0].material.opacity = 1;
          flash.scale.set(.1, .1, .1);
          flash.position.copy(sandbox.models["player"].object.position);
          flash.rotation.copy(sandbox.models["player"].object.rotation);
          flash.translateY(.96);
          flash.rotateY(Math.PI);
          flash.translateX(.08);
          flash.translateZ(-.7);
          let light = new THREE.PointLight(0xf99c00, 1, 4, 3);
          light.position.copy(flash.position);
          light.rotation.copy(flash.rotation);
          scene.add(flash);
          scene.add(light);
          let lightClone = light.clone();
          weaponScene.add(lightClone);
          setTimeout(() => (scene.remove(light), weaponScene.remove(lightClone), scene.remove(flash)), 50);
        }
        if (!isUser && action == "pickup") {
          let newPrimaryWeapon = sandbox.models[metadata.loadout[0]].object;
          let newSecondaryWeapon = sandbox.models[metadata.loadout[1]].object;
          newPrimaryWeapon.scale.set(10, 10, 10);
          newSecondaryWeapon.scale.set(10, 10, 10);
          let position = character.currentWeapon == character.primaryWeapon ? 0 : 1;
          gunHolder.remove(character.currentWeapon);
          character.primaryWeapon = newPrimaryWeapon;
          character.secondaryWeapon = newSecondaryWeapon;
          character.currentWeapon = position == 0 ? character.secondaryWeapon : character.primaryWeapon;
          character.loadout = metadata.loadout;
          gunHolder.add(character.currentWeapon);
        }
        if (!isUser && action == "remove") {
          let weaponBox = utils.options.get("WeaponBoxes")[metadata.id];
          if (!weaponBox) return;
          pointers[metadata.id].position.y = -10000;
          scene.remove(pointers[metadata.id]);
          delete pointers[metadata.id];
          scene.remove(weaponBox);
          weaponBox.position.y = -10000;
        }
        if (!isUser && action == "hit") {
          document.querySelector(".hit").style.opacity = .5;
          setTimeout(() => (document.querySelector(".hit").style.opacity = 0), 200);
          utils.camera.shake(metadata.damage / 10 >= 2 ? 2 : metadata.damage / 10);
          clearTimeout(utils.options.get("HealthRegenerator"));
          utils.options.set("HealthRegenerator", setTimeout(() => {
            let regeneration = setInterval(() => {
              if (utils.options.get("Health") >= 100) {
                utils.options.set("Health", 100);
                return clearInterval(regeneration);
              }
              utils.options.set("Health", utils.options.get("Health") + 1);
            });
          }, 5000));
          utils.options.set("Health", utils.options.get("Health") - metadata.damage);
          if (utils.options.get("Health") <= 0) {
            utils.weapons.data(sandbox.currentWeapon).then(weapon => {
              call("die", {
                name: sandbox.users[sandbox.users.map(x => x.username != (userMan.isLoggedIn ? userMan.get("username") : sandbox.tempName)).indexOf(true)].username,
                weapon: Object.keys(sandbox.models)[Object.keys(sandbox.models).map(x => x == (character.currentWeapon == character.primaryWeapon ? character.loadout[0] : character.loadout[1])).indexOf(true)]
              });
            });
          }
        }
        if (!isUser && action == "explosion") {
          let object = new THREE.Mesh();
          object.position.set(metadata.position[0], metadata.position[1], metadata.position[2]);
          utils.explosion(object, false);
        }
        if (isUser && action == "die") {
          if (utils.options.get("Killed")) return;
          document.querySelector(".leaderboard").style.border = "4px solid #ff0000";
          setTimeout(() => document.querySelector(".leaderboard").style.border = "4px solid transparent", 2000);
          utils.options.set("Killed", true);
          if (gametime.user.position == 1) {
            sandbox.points[1]++;
          } else sandbox.points[0]++;
          PointerControls.isLocked = false;
          TouchControls.isLocked = false;
          GamepadControls.isLocked = false;
          document.querySelector(".ui").style.visibility = "hidden";
          utils.ui.dialog("You died", "You were killed by " + metadata.name + " using " + metadata.weapon.replace(/_/gi, " "), 4000);
          setTimeout(() => {
            utils.respawn();
            utils.options.set("Killed", false);
          }, 4000);
          weaponScene.remove(sandbox.currentWeapon);
        }
        if (!isUser && action == "die") {
          if (utils.options.get("OtherKilled")) return;
          document.querySelector(".leaderboard").style.border = "4px solid #4ed64e";
          setTimeout(() => document.querySelector(".leaderboard").style.border = "4px solid transparent", 2000);
          utils.options.set("OtherKilled", true);
          setTimeout(() => utils.options.set("OtherKilled", false), 2000);
          sandbox.kills++;
          sandbox.models["player"].object.position.y = -10000;
          if (gametime.user.position == 1) {
            sandbox.points[0]++;
            utils.ui.medal("kill", 10);
            new THREE.Sound("sounds/kill.mp3", null, () => {}, false);
            utils.weapons.data(sandbox.currentWeapon).then(weapon => {
              if (weapon.ammo == "rocket") {
                utils.ui.medal("rocket_kill", 10);
              }
              if (weapon.ammo == "grenade") {
                utils.ui.medal("grenade_kill", 15);
              }
              if (weapon.rounds <= weapon.minRounds && weapon.ammo != "rocket" && weapon.ammo != "grenade" && weapon.name != "Knife") {
                utils.ui.medal("last_shot", 10);
              }
              if (weapon.ammo == "sniper") {
                if (!utils.options.get("Zoomed")) {
                  utils.ui.medal("no_scope", 15);
                }
                utils.ui.medal("sniper_kill", 5);
              }
            });
          } else {
            sandbox.points[1]++;
            utils.ui.medal("kill", 10);
            new THREE.Sound("sounds/kill.mp3", null, () => {}, false);
            utils.weapons.data(sandbox.currentWeapon).then(weapon => {
              if (weapon.ammo == "rocket") {
                utils.ui.medal("rocket_kill", 10);
              }
              if (weapon.ammo == "grenade") {
                utils.ui.medal("grenade_kill", 15);
              }
              if (weapon.rounds <= weapon.minRounds && weapon.ammo != "rocket" && weapon.ammo != "grenade") {
                utils.ui.medal("last_shot", 10);
              }
              if (weapon.ammo == "sniper") {
                if (!utils.options.get("Zoomed")) {
                  utils.ui.medal("no_scope", 15);
                }
                utils.ui.medal("sniper_kill", 5);
              }
            });
          }
        }
        if (!isUser && action == "respawn") {
          sandbox.models["player"].object.position.set(metadata.position[0], metadata.position[1] - 1, metadata.position[2]);
          sandbox.models["player"].object.rotation.set(metadata.position[3], metadata.position[4], metadata.position[5]);
          sandbox.models["player"].object.rotateY(Math.PI);
        }
      });
      function call(action, metadata, bot = false) {
        let parsedMetaData = JSON.stringify(metadata).replace(/(\")/gi, "'");
        let parameters = (bot ? (gametime.user.position == 1 ? 2 : 1) : gametime.user.position) + "," + action.toString() + "," + parsedMetaData;
        gametime.run("playerAction", [parameters.toString()]);
      }

      // Bot setup
      if (new URLSearchParams(location.search).get("bot")) {
        sandbox.users.push({
          player: sandbox.users.length + 1,
          username: generateName()
        });
        let check = setInterval(() => {
          if (document.querySelector(".before-ui").style.visibility == "hidden") {
            let bot = sandbox.models["player"].object;
            let walk = true;
            let time = 0;
            const botCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            bot.add(botCamera);
            setInterval(() => {
              time++;
              botCamera.updateMatrix();
              botCamera.updateMatrixWorld();
              let frustum = new THREE.Frustum();
              frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(botCamera.projectionMatrix, botCamera.matrixWorldInverse));
              let position = camera.position;
              if (frustum.containsPoint(position)) {
                bot.lookAt(camera.position);
                bot.rotation.x = 0;
                bot.rotation.z = 0;
                if (bot.position.distanceTo(camera.position) <= 5) {
                  bot.translateZ(-.5);
                }
                setTimeout(() => call("shoot", {
                  weapon: character.loadout[character.currentWeapon == character.primaryWeapon ? 0 : 1]
                }, true), time * 400);
              }
              if (bot.position.distanceTo(camera.position) <= 10 && Math.floor(Math.random() * 250) == 0) {
                let grenade = new THREE.Mesh();
                grenade.position.copy(camera.position);
                grenade.position.y += -1;
                grenade.translateX(Math.floor(Math.random() * 2) == 0 ? Math.floor(Math.random() * 4) : -Math.floor(Math.random() * 4));
                grenade.translateZ(Math.floor(Math.random() * 2) == 0 ? Math.floor(Math.random() * 4) : -Math.floor(Math.random() * 4));
                let status = utils.options.get("BotStatus");
                status.grenades--;
                utils.options.set("BotStatus", status);
                !status.grenades <= 0 || utils.explosion(grenade, false);
              }
              if (Math.floor(Math.random() * 200) == 0) {
                call("switch", {}, true);
              }
              let playerForwardTarget = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1));
              let playerBackwardTarget = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1));
              let playerLeftTarget = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1));
              let playerRightTarget = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1));
              playerForwardTarget.position.copy(bot.position);
              playerBackwardTarget.position.copy(bot.position);
              playerLeftTarget.position.copy(bot.position);
              playerRightTarget.position.copy(bot.position);
              playerForwardTarget.rotation.copy(bot.rotation);
              playerBackwardTarget.rotation.copy(bot.rotation);
              playerLeftTarget.rotation.copy(bot.rotation);
              playerRightTarget.rotation.copy(bot.rotation);
              playerForwardTarget.translateZ(1);
              playerBackwardTarget.translateZ(-1);
              playerLeftTarget.translateX(1);
              playerRightTarget.translateX(-1);
              map.traverse(object => {
                if (object.name.includes("Cube")) return;
                if (collision(object, playerForwardTarget)) {
                  bot.translateZ(-.1);
                  sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).stop();
                  sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).reset();
                }
                if (collision(object, playerBackwardTarget)) {
                  bot.translateZ(.1);
                }
                if (collision(object, playerLeftTarget)) {
                  bot.rotateY(-.01);
                }
                if (collision(object, playerRightTarget)) {
                  bot.rotateY(.01);
                }
              });
              if (walk) {
                bot.translateZ(.01);
                sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).play();
              } else {
                bot.rotateY(Math.floor(Math.random() * 2) == 0 ? -Math.random() / 2 : Math.random() / 2);
                sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).stop();
                sandbox.models["player"].mixer.clipAction(sandbox.models["player"].animations[0]).reset();
              }
            });
            setInterval(() => {
              if (Math.floor(Math.random() * 20) == 0) {
                walk = false;
                Math.floor(Math.random() * 10) == 0 && bot.rotateY(Math.random());
              } else {
                walk = true;
              }
            });
            clearInterval(check);
          }
        });
      }

      let params = { code: "ShiftLeft", key: "Shift" };
      const TouchUI = new UI("touch", function(type, parameters) {
        if (type == "move") {
          if (parameters.positive) {
            if (parameters.where == "forward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" }));
              if (parameters.run) {
                !params.repeat && document.dispatchEvent(new KeyboardEvent("keydown", params));
                params.repeat = true;
              } else {
                params.repeat = false;
                document.dispatchEvent(new KeyboardEvent("keyup", params));
              }
            } else if (parameters.where == "forward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "forward-right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyD", key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
            } else if (parameters.where == "right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyD", key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
            } else if (parameters.where == "backward-right") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyS", key: "s" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyD", key: "d" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
            } else if (parameters.where == "backward") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "backward-left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyS", key: "s" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            } else if (parameters.where == "forward-left") {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyW", key: "w" })), document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyA", key: "a" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
              document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            }
          } else {
            params.repeat = false;
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyW", key: "w" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyA", key: "a" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyS", key: "s" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyD", key: "d" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "ShiftLeft", key: "Shift" }));
          }
        } else if (type == "jump") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "Space", key: " " }));
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "Space", key: " " }));
          }
        } else if (type == "shoot") {
          if (parameters.positive) {
            utils.options.get("Zoomed") || document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyI", key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyI", key: "i" }));
            setTimeout(() => {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyF", key: "f" }));
            }, 100);
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyF", key: "f" }));
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyI", key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyI", key: "i" }));
            keyStates["KeyF"] = false;
            keyStates["KeyI"] = false;
          }
        } else if (type == "fire") {
          if (parameters.positive) {
              document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyF", key: "f" }));
          } else {
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyF", key: "f" }));
            keyStates["KeyF"] = false;
          }
        } else if (type == "zoom") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyI", key: "i" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyI", key: "i" }));
          }
        } else if (type == "reload") {
          utils.weapons.data(sandbox.currentWeapon).then(x => {
            let weapon = x;
            let cweapon = sandbox.weapons[sandbox.weapons.indexOf(weapon)];
            if (cweapon.rounds < cweapon.maxRounds) {
              utils.weapons.reload();
            }
          });
        } else if (type == "throw") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyM", key: "m" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyM", key: "m" }));
          }
        } else if (type == "melee") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyB", key: "b" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyB", key: "b" }));
          }
        } else if (type == "swap") {
          if (parameters.positive) {
            document.dispatchEvent(new KeyboardEvent("keydown", { code: "KeyY", key: "y" }));
            document.dispatchEvent(new KeyboardEvent("keyup", { code: "KeyY", key: "y" }));
          }
        }
      });
      document.querySelector(".loading").style.backgroundImage = "url(images/assets/maps/" + sandbox.map + ".png)";
      if (utils.options.get("TouchDevice")) document.body.appendChild(TouchUI.domElement);
      let loaderInterval = setInterval(() => {
        document.querySelector(".loading-bar").style.width = ((document.querySelector(".loading-bar").style.width.split("%")[0] - 0) + .5) + "%";
        document.querySelector(".loading-progress").textContent = ((document.querySelector(".loading-bar").style.width.split("%")[0] > 100 ? 100 : document.querySelector(".loading-bar").style.width.split("%")[0]) - 0).toFixed(0);
        let loadedModels = 0;
        Object.values(sandbox.models).forEach(x => {
          if (x.object != null) {
            loadedModels++;
          }
        });
        sandbox.weapons.forEach(x => {
          if (x.object != null) {
            loadedModels++;
          }
        });
        if (loadedModels >= ((Object.values(sandbox.models).length - 1) + sandbox.weapons.length) && map != null) {
          document.querySelector(".loading").style.opacity = 0;
          document.querySelector(".loading").style.width = "100%";
          sandbox.users.forEach(x => {
            document.querySelector(".users").innerHTML += `
            <div class="column">${x.player} - ${x.username} <div class="spin"></div>
            `;
          });
          sandbox.users.push({});
          document.querySelector(".description-header").textContent = sandbox.mode;
          document.querySelector(".description-text").textContent = sandbox.descriptions[sandbox.mode];
          utils.respawn(false);
          let playerLoader = setInterval(() => {
            if (sandbox.users.length >= sandbox.players) {
              weaponScene.remove(sandbox.currentWeapon);
              document.querySelector(".ui").style.visibility = "hidden";
              utils.respawn(false);
              setTimeout(() => {
                camera.fov = 30;
                camera.updateProjectionMatrix();
                weaponCamera.fov = 30;
                weaponCamera.updateProjectionMatrix();
                utils.respawn(false);
              }, 2000);
              setTimeout(() => {
                document.querySelector(".banner").style.opacity = 0;
                document.querySelector(".before-ui").style.visibility = "visible";
                let t = 10;
                let timer = setInterval(() => {
                  if (t <= 0) {
                    new THREE.Sound("sounds/load.mp3", null, () => {}, false);
                    new THREE.Sound("sounds/ambience.mp3", null, () => {}, false, true);
                    document.querySelector(".before-ui").style.visibility = "hidden";
                    return clearInterval(timer);
                  }
                  t--;
                  t < 4 && new THREE.Sound("sounds/tick.mp3", null, () => {}, false);
                  document.querySelector(".counter").textContent = t;
                }, 950);
                utils.options.set("Starting", true);
              }, 4000);
              clearInterval(playerLoader);
            }
          });
          clearInterval(loaderInterval);
        }
      });
      gametime.onconnect = function() {
        let username = userMan.isLoggedIn ? userMan.get("username") : sandbox.tempName;
        for (let i = 0; i < 2; i++) {
          call("info", {
            username: username,
            loadout: sandbox.loadout
          });
        }
      };

      if (new URLSearchParams(location.search).get("freeplay")) {
        utils.respawn = () => {};
        sandbox.players = 1;
        sandbox.users.push({
          player: 1,
          username: (userMan.isLoggedIn ? userMan.get("username") : generateName())
        });
        gametime.make = () => {};
        gametime.on = () => {};
        gametime.run = () => {};
      }
    </script>
  </body>
</html>